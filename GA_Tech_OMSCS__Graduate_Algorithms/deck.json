{
    "__type__": "Deck",
    "children": [
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f550f6c-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "0-Black Box Algorithms",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::BFS}}\n</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected; vertex \\(s \\in V\\)}}</li><li>Output: {{c2::dist[u], prev[z]}}</li><li>Runtime: {{c3::\\(O(m + n)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "qa(-2Wluf1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Dijkstra's}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected; vertex \\(s \\in V\\); w+}}</li><li>Output: {{c2::dist[u], prev[z]}}</li><li>Runtime: {{c3::\\(O((m + n) \\log n)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "unps_durDw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::DFS}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected}}</li><li>Output: {{c2::prev[z], pre[z], post[z], ccnum[z]}}</li><li>Runtime: {{c3::\\(O(m + n)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "@?@s+[POp",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Explore}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected, \\(v \\in V\\)}}</li><li>Output: {{c2::visited[u]}}</li><li>Runtime: {{c3::\\(O(n + m)\\) for independent version, \\(O(m)\\) when part of DFS}}</li></ul>\n",
                        "Initializing visited[] takes \\(O(n)\\) if it is not already done as part of DFS."
                    ],
                    "guid": "rz%0l)+mQA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::SCC Algorithm}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed}}</li><li>Output: {{c2::\\(G^{SCC} = (V^{SCC}, E^{SCC})\\), ccnum[]}}</li><li>Runtime: {{c3::\\(O(m+n)\\)}}</li></ul>\n",
                        "\\(G^{SCC}\\) is a metagraph (DAG) of the SCCs, while <b>ccnum[]</b> gives the SCC for the original vertices in V."
                    ],
                    "guid": "qZU%XGNv;@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Topological Sort Algorithm}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed acyclic graph (DAG)}}</li><li>Output: {{c2::topo[i] }}</li><li>Runtime: {{c3::\\(O(n+m)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "qW/]m-u.w9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Kruskal's MST Algorithm}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), connected, undirected;&nbsp;\\(w\\pm\\)}}</li><li>Output: {{c2::MST defined by the edges \\(E^{MST}\\) }}</li><li>Runtime: {{c3::\\(O(m \\log n)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "b/P=jKWie]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Prim's MST Algorithm}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), connected, undirected; \\(w\\pm\\)}}</li><li>Output: {{c2::MST defined by prev[z] }}</li><li>Runtime: {{c3::\\(O(m \\log n)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "PW8Ld|-t*%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Bellman-Ford}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected; vertex \\(s \\in V\\); \\(w\\pm\\)}}</li><li>Output: {{c2::Single Source Shortest Path }}</li><li>Runtime: {{c3::\\(O(nm)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "BQi~,9G:V>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Floyd-Warshall}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), directed or undirected; \\(w\\pm\\)}}</li><li>Output: {{c2::All Pair Shortest Path }}</li><li>Runtime: {{c3::\\(O(n^3)\\)}}</li></ul>\n",
                        ""
                    ],
                    "guid": "AYRPo[]G44",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Ford-Fulkerson}}</h2>\n<ul><li>Input: {{c1::\\(\\overrightarrow{G} = (V, \\overrightarrow{E})\\), s, t, c}}</li><li>Output: {{c2::Maximum size f }}</li><li>Runtime: {{c3::\\(O(mC)\\) where C is the max flow}}</li></ul>\n",
                        ""
                    ],
                    "guid": "o@cF[;#7Vq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Black Box Graph Algorithms</h1>\n<h2>\n  {{c4::Edmonds-Karp}}</h2>\n<ul><li>Input: {{c1::\\(G = (V, E)\\), s, t, c}}</li><li>Output: {{c2::Maximum size f }}</li><li>Runtime: {{c3::\\(O(nm^2)\\) }}</li></ul>\n",
                        ""
                    ],
                    "guid": "F{gf.K8%_*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\nMax-SAT:<br><ul><li>input: {{c1::Boolean formula f in CNF with n variables and m clauses}}</li><li>output: {{c2::assignement maximizing # of satisfied clauses}}</li><li>complexity: {{c3::NP-hard}}</li></ul>",
                        "<i>Source: Lecture LP4, Section 1</i>"
                    ],
                    "guid": "Q6d,<0m_*b",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam3",
                        "linear_programming",
                        "max_sat"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f576ec4-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "0-Prerequisite",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2><div>Let <i>f(n)</i> and <i>g(n)</i> be functions from positive integers to positive reals. We say&nbsp;<i>f = O(g)</i> (which means that “{{c1::f grows no faster than g}}”) if {{c2::there is a constant <i>c &gt; 0</i>&nbsp;such that <i>f(n) ≤ c · g(n)</i>}}.</div>",
                        ""
                    ],
                    "guid": "yh/sh6V<`t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2><div>Saying {{c1::<i>f = O(g)</i>}} is a very loose analog of “{{c2::<i>f ≤ g</i>}}.”<br></div>",
                        ""
                    ],
                    "guid": "w?MjYK[F8)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2><div>{{c1::<i>f = Ω(g)</i>}} means <i>g =&nbsp;</i>{{c2::<i>O(f)</i>}}</div>",
                        ""
                    ],
                    "guid": "wh1522|>e.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2><div>{{c1::<i>f = Θ(g)</i>}} means {{c2::<i>f = O(g)</i> and <i>f = Ω(g)</i>}}.<br></div>",
                        ""
                    ],
                    "guid": "A,S7KnAE>r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2><ul><li>Big O gives {{c1::an upper&nbsp;asymptotic bound}}.</li><li>Big Omega gives {{c1::a lower asymptotic bound}}.<br></li><li>Big Theta gives {{c1::both}}.</li></ul>",
                        "e.g. if a function is&nbsp;Ө(n), then for a sufficiently large&nbsp;n, it is sandwiched between two linear functions."
                    ],
                    "guid": "CF8so{O:h^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2>Here are some commonsense rules that help simplify functions by omitting dominated&nbsp;terms:<br><ol><li>{{c1::Multiplicative constants can be omitted}}</li><li>{{c2::\\(n^a\\) dominates \\(n^b\\) if \\(a {\\gt} b\\)}}</li><li>{{c3::Any exponential dominates any polynomial}}</li><li>{{c4::Any polynomial dominates any logarithm}}</li></ol>",
                        "<ol><li>\\(14n^2\\) becomes \\(n^2.\\)</li><li>\\(n^2\\) dominates n.</li><li>\\(3^n\\) dominates \\(n^5\\) (it even dominates \\(2^n\\)).</li><li>n dominates \\((\\log n)^3\\) . This also&nbsp;means, for example, that \\(n^2\\) dominates \\(n \\log n\\).</li></ol>"
                    ],
                    "guid": "fPjm*VH8H:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>0.3 Big-O notation<br></h2>Orders of common functions<br><br>\n<table border=\"1\">\n<tbody>\n<tr>\n<th>Notation</th>\n<th>Name</th>\n<th>Example</th>\n</tr>\n<tr>\n<td>{{c1::\\(O(1)\\)}}</td>\n<td><a title=\"Constant time\" href=\"https://en.wikipedia.org/wiki/Constant_time\">{{c1::constant}}</a></td>\n<td>{{c1::Determining if a binary number is even or odd; Calculating \\((-1)^{n}\\); Using a constant-size&nbsp;<a title=\"Lookup table\" href=\"https://en.wikipedia.org/wiki/Lookup_table\">lookup table</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c2::\\(O(\\log \\log n)\\)}}</td>\n<td>{{c2::double logarithmic\n}}</td><td>{{c2::Number of comparisons spent finding an item using&nbsp;<a title=\"Interpolation search\" href=\"https://en.wikipedia.org/wiki/Interpolation_search\">interpolation search</a>&nbsp;in a sorted array of uniformly distributed values}}<br></td>\n</tr>\n<tr>\n<td>{{c3::\\(O(\\log n)\\)}}</td>\n<td><a title=\"Logarithmic time\" href=\"https://en.wikipedia.org/wiki/Logarithmic_time\">{{c3::logarithmic}}</a></td>\n<td>{{c3::Finding an item in a sorted array with a&nbsp;<a title=\"Binary search algorithm\" href=\"https://en.wikipedia.org/wiki/Binary_search_algorithm\">binary search</a>&nbsp;or a balanced search&nbsp;<a title=\"Tree data structure\" href=\"https://en.wikipedia.org/wiki/Tree_data_structure\">tree</a>&nbsp;as well as all operations in a&nbsp;<a title=\"Binomial heap\" href=\"https://en.wikipedia.org/wiki/Binomial_heap\">Binomial heap</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c4::\\(O((\\log n)^{c})\\)<br>\\(c{\\gt}1\\)}}<br></td>\n<td><a title=\"Polylogarithmic time\" href=\"https://en.wikipedia.org/wiki/Polylogarithmic_time\">{{c4::polylogarithmic}}</a></td>\n<td>{{c4::Matrix chain ordering can be solved in polylogarithmic time on a&nbsp;<a title=\"Parallel random-access machine\" href=\"https://en.wikipedia.org/wiki/Parallel_random-access_machine\">parallel random-access machine</a>.}}<br></td>\n</tr>\n<tr>\n<td>{{c5::\\(O(n^{c})\\)<br>\\(0{\\lt}c{\\lt}1\\)}}<br></td>\n<td>{{c5::fractional power}}</td>\n<td>{{c5::Searching in a&nbsp;<a title=\"K-d tree\" href=\"https://en.wikipedia.org/wiki/K-d_tree\">k-d tree</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c6::\\(O(n)\\)}}</td>\n<td><a title=\"Linear time\" href=\"https://en.wikipedia.org/wiki/Linear_time\">{{c6::linear}}</a></td>\n<td>{{c6::Finding an item in an unsorted list or in an unsorted array; adding two&nbsp;<em>n</em>-bit integers by&nbsp;<a title=\"Ripple carry adder\" href=\"https://en.wikipedia.org/wiki/Ripple_carry_adder\">ripple carry</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c7::\\(O(n\\log ^{*}n)\\)}}</td>\n<td>{{c7::<em>n</em>&nbsp;<a title=\"Log-star\" href=\"https://en.wikipedia.org/wiki/Log-star\">log-star</a>&nbsp;<em>n</em>}}<br></td>\n<td>{{c7::Performing&nbsp;<a title=\"Polygon triangulation\" href=\"https://en.wikipedia.org/wiki/Polygon_triangulation\">triangulation</a>&nbsp;of a simple polygon using&nbsp;<a title=\"Kirkpatrick–Seidel algorithm\" href=\"https://en.wikipedia.org/wiki/Kirkpatrick%E2%80%93Seidel_algorithm\">Seidel's algorithm</a>, or the&nbsp;<a title=\"Disjoint-set data structure\" href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Proof_of_O(log*(n))_time_complexity_of_Union-Find\">union–find algorithm</a>.}}<br>Note that&nbsp;<br>\\[\\log ^{*}(n)={\\begin{cases}0,&amp;{\\text{if }}n\\leq 1\\\\1+\\log ^{*}(\\log n),&amp;{\\text{if }}n{\\gt}1\\end{cases}}\\]<br></td>\n</tr>\n<tr>\n<td>{{c8::\\(O(n\\log n)=O(\\log n!)\\)}}</td>\n<td>{{c8::<a title=\"Linearithmic time\" href=\"https://en.wikipedia.org/wiki/Linearithmic_time\">linearithmic</a>, loglinear, quasilinear, or \"<em>n</em>&nbsp;log <em>n</em>\"}}<br></td>\n<td>{{c8::Performing a&nbsp;<a title=\"Fast Fourier transform\" href=\"https://en.wikipedia.org/wiki/Fast_Fourier_transform\">fast Fourier transform</a>; Fastest possible&nbsp;<a title=\"Comparison sort\" href=\"https://en.wikipedia.org/wiki/Comparison_sort\">comparison sort</a>;&nbsp;<a title=\"Heapsort\" href=\"https://en.wikipedia.org/wiki/Heapsort\">heapsort</a>&nbsp;and&nbsp;<a title=\"Merge sort\" href=\"https://en.wikipedia.org/wiki/Merge_sort\">merge sort</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c9::\\(O(n^{2})\\)}}</td>\n<td><a title=\"Quadratic time\" href=\"https://en.wikipedia.org/wiki/Quadratic_time\">{{c9::quadratic}}</a></td>\n<td>{{c9::Multiplying two&nbsp;<em>n</em>-digit numbers by a simple algorithm; simple sorting algorithms, such as&nbsp;<a title=\"Bubble sort\" href=\"https://en.wikipedia.org/wiki/Bubble_sort\">bubble sort</a>,&nbsp;<a title=\"Selection sort\" href=\"https://en.wikipedia.org/wiki/Selection_sort\">selection sort</a>&nbsp;and&nbsp;<a title=\"Insertion sort\" href=\"https://en.wikipedia.org/wiki/Insertion_sort\">insertion sort</a>; (worst case) bound on some usually faster sorting algorithms such as&nbsp;<a title=\"Quicksort\" href=\"https://en.wikipedia.org/wiki/Quicksort\">quicksort</a>,&nbsp;<a title=\"Shellsort\" href=\"https://en.wikipedia.org/wiki/Shellsort\">Shellsort</a>, and&nbsp;<a title=\"Tree sort\" href=\"https://en.wikipedia.org/wiki/Tree_sort\">tree sort</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c10::\\(O(n^{c})\\)}}</td>\n<td>{{c10::<a title=\"Polynomial time\" href=\"https://en.wikipedia.org/wiki/Polynomial_time\">polynomial</a>&nbsp;or algebraic}}<br></td>\n<td>{{c10::<a title=\"Tree-adjoining grammar\" href=\"https://en.wikipedia.org/wiki/Tree-adjoining_grammar\">Tree-adjoining grammar</a>&nbsp;parsing; maximum&nbsp;<a title=\"Matching (graph theory)\" href=\"https://en.wikipedia.org/wiki/Matching_(graph_theory)\">matching</a>&nbsp;for&nbsp;<a title=\"Bipartite graph\" href=\"https://en.wikipedia.org/wiki/Bipartite_graph\">bipartite graphs</a>; finding the&nbsp;<a title=\"Determinant\" href=\"https://en.wikipedia.org/wiki/Determinant\">determinant</a>&nbsp;with&nbsp;<a title=\"LU decomposition\" href=\"https://en.wikipedia.org/wiki/LU_decomposition\">LU decomposition</a>}}<br></td>\n</tr>\n<tr>\n<td>\n<p>{{c11::</p><p>\\(L_{n}[\\alpha ,c]=e^{(c+o(1))(\\ln n)^{\\alpha }(\\ln \\ln n)^{1-\\alpha} }\\)<br><br>\\(0{\\lt}\\alpha {\\lt}1\\)<br></p><p>\n}}<br></p>\n</td>\n<td>{{c11::<a title=\"L-notation\" href=\"https://en.wikipedia.org/wiki/L-notation\">L-notation</a>&nbsp;or&nbsp;<a title=\"Sub-exponential time\" href=\"https://en.wikipedia.org/wiki/Sub-exponential_time\">sub-exponential</a>}}<br></td>\n<td>{{c11::Factoring a number using the&nbsp;<a title=\"Quadratic sieve\" href=\"https://en.wikipedia.org/wiki/Quadratic_sieve\">quadratic sieve</a>&nbsp;or&nbsp;<a title=\"Number field sieve\" href=\"https://en.wikipedia.org/wiki/Number_field_sieve\">number field sieve</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c12::\\(O(c^{n})\\)<br>\\(c{\\gt}1\\)}}<br></td>\n<td><a title=\"Exponential time\" href=\"https://en.wikipedia.org/wiki/Exponential_time\">{{c12::exponential}}</a></td>\n<td>{{c12::Finding the (exact) solution to the&nbsp;<a title=\"Travelling salesman problem\" href=\"https://en.wikipedia.org/wiki/Travelling_salesman_problem\">travelling salesman problem</a>&nbsp;using&nbsp;<a title=\"Dynamic programming\" href=\"https://en.wikipedia.org/wiki/Dynamic_programming\">dynamic programming</a>; determining if two logical statements are equivalent using&nbsp;<a title=\"Brute-force search\" href=\"https://en.wikipedia.org/wiki/Brute-force_search\">brute-force search</a>}}<br></td>\n</tr>\n<tr>\n<td>{{c13::\\(O(n!)\\)}}</td>\n<td><a title=\"Factorial\" href=\"https://en.wikipedia.org/wiki/Factorial\">{{c13::factorial}}</a></td>\n<td>{{c13::Solving the&nbsp;<a title=\"Travelling salesman problem\" href=\"https://en.wikipedia.org/wiki/Travelling_salesman_problem\">travelling salesman problem</a>&nbsp;via brute-force search; generating all unrestricted permutations of a&nbsp;<a title=\"Partially ordered set\" href=\"https://en.wikipedia.org/wiki/Partially_ordered_set\">poset</a>; finding the&nbsp;<a title=\"Determinant\" href=\"https://en.wikipedia.org/wiki/Determinant\">determinant</a>&nbsp;with&nbsp;<a title=\"Laplace expansion\" href=\"https://en.wikipedia.org/wiki/Laplace_expansion\">Laplace expansion</a>; enumerating&nbsp;<a title=\"Bell number\" href=\"https://en.wikipedia.org/wiki/Bell_number\">all partitions of a set</a>}}<br></td>\n</tr>\n</tbody>\n</table>",
                        ""
                    ],
                    "guid": "J01#iH;wlj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\(\\log_b({{c1::1}}) = {{c2::0}}\\)<br>",
                        "Because&nbsp;\\(b^0 = 1\\), given that <i>b</i>&nbsp;doesn't equal <i>0</i>."
                    ],
                    "guid": "ehs:aAK97>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\(\\log_b({{c1::b}}) = {{c2::1}}\\)<br>",
                        "Because&nbsp;\\(b^1 = b\\)"
                    ],
                    "guid": "IcLI|-Q#^y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\(b^{{{c1::\\log_b (x)}}} = {{c2::x}}\\)<br>",
                        "Because \\(antilog_b(\\log_b(x)) = x\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "mmtXYBrF2<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\(\\log_b({{c2::b^x}}) = {{c1::x}}\\)<br>",
                        "Because \\(log_b(antilog_b(x)) = x\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "B5@w+I@1]t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::b^c}} = {{c2::x}} \\iff {{c3::\\log_b(x)}} = {{c4::c}}\\)<br>",
                        "<span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "FaA<c.Cb4U",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::\\log_b(xy)}} = {{c2::\\log_b(x) + \\log_b(y)}}\\)<br>",
                        "Because \\(b^cb^d = b^{c+d}\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "fINU0F0jAv",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::\\log_b(\\tfrac{x}{y})}} = {{c2::\\log_b(x)-\\log_b(y)}}\\)<br>",
                        "Because \\(\\tfrac{b^c}{b^d} = b^{c-d}\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "zEj+ZzT+.#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::\\log_b(x^d)}}={{c2::d \\log_b(x)}}\\)<br>",
                        "Because \\((b^c)^d = b^{cd}\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "rny0N`Cy*T",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::\\log_b(\\sqrt[y]{x})}} = {{c2::\\frac{\\log_b(x)}{y} }}\\)<br>",
                        "Because \\(\\sqrt[y]{x} = x^{1/y}\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b \\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "eqFgD=cq(b",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::x^{\\log_b(y)} }}={{c2::y^{\\log_b(x)} }}\\)<br>",
                        "Because \\(x^{\\log_b(y)}=b^{\\log_b(x)\\log_b(y)}=(b^{\\log_b(y))})^{\\log_b(x)}=y^{\\log_b(x)}\\)<br><span style=\"color: rgb(32, 33, 34);\">Where&nbsp;<i>b</i>,&nbsp;<i>x</i>, and&nbsp;<i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and&nbsp;</span>\\(b\\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "iQ5K;2=L)L",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\\({{c1::c\\log_b(x)+d\\log_b(y)}}={{c2::\\log_b(x^cy^d)}}\\)<br>",
                        "Because \\(\\log_b(x^cy^d)=\\log_b(x^c)+\\log_b(y^d)\\)<br><span style=\"color: rgb(32, 33, 34);\">Where <i>b</i>, <i>x</i>, and <i>y</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are positive real numbers and</span><span style=\"color: rgb(32, 33, 34);\">&nbsp;</span>\\(b\\neq 1\\)<span style=\"color: rgb(32, 33, 34);\">, and&nbsp;<i>c</i>&nbsp;</span><span style=\"color: rgb(32, 33, 34);\">and&nbsp;<i>d</i></span><span style=\"color: rgb(32, 33, 34);\">&nbsp;are real numbers.</span>"
                    ],
                    "guid": "IEdKj[sHqj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Logarithmic Identities</h1>\n<h2>Change Base</h2>\n\\(\\log_ba = {{c1::\\frac{\\log_d(a)}{\\log_d(b)} }}\\)",
                        ""
                    ],
                    "guid": "n_*Q:ME=7-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam1"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f592976-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "Complex_number_illustration.svg",
                "paste-352d3d7fa43bb11d000759befcecbd86db48c8d3.jpg",
                "paste-b85c8ad5977f29296812749f4181a1c440e5df0f.jpg"
            ],
            "name": "DC",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>The recurrence \\(T(n) = 3(n/2) + O(n)\\) divides the problem in 2 at each step and so will have {{c1::\\(\\log_2n\\)}} levels/height.",
                        ""
                    ],
                    "guid": "Cl%HzQ~wn|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>The recurrence \\(T(n) = 3(n/2) + O(n)\\) has a branching factor of {{c1::3}}, meaning {{c1::each problem produces 3 smaller ones}}.",
                        ""
                    ],
                    "guid": "uUb)Vk@OA@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>For the recurrence \\(T(n) = 3T(n/2) + O(n)\\), at depth <i>k</i>&nbsp;there are {{c1::\\(3^k\\)}} subproblems each of size {{c1::\\(\\frac{n}{2^k}\\)}}.",
                        ""
                    ],
                    "guid": "OG+M?9n]Bn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>For the recurrence \\(T(n) = 3T(n/2) + O(n)\\), the total time spent at depth <i>k</i>&nbsp;is:",
                        "\\(3^k \\times O\\left(\\frac{n}{2^k}\\right) = \\left( \\frac{3}{2} \\right)^k \\times O(n)\\)"
                    ],
                    "guid": "edVbn+<_k=",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>For the recurrence \\(T(n) = 3(n/2) + O(n)\\), the total time spent at depth <i>k</i>&nbsp;is:<br>\\(3^k \\times O\\left(\\frac{n}{2^k}\\right) = \\left( \\frac{3}{2} \\right)^k \\times O(n)\\)<br><br>How much time is spent when \\(k=0\\)?",
                        "\\(O(n)\\)"
                    ],
                    "guid": "N3aTqbk@Qo",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>For the recurrence \\(T(n) = 3(n/2) + O(n)\\), the total time spent at depth <i>k</i>&nbsp;is:<br>\\(3^k \\times O\\left(\\frac{n}{2^k}\\right) = \\left( \\frac{3}{2} \\right)^k \\times O(n)\\)<br><br>How much time is spent when \\(k=\\log_2 n\\)?",
                        "\\(O(3^{\\log_2 n}) = O(n^{\\log_2 3})\\)"
                    ],
                    "guid": "fDcB_iv^zm",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>\n  What is the divide-and-conquer master theorem?</h3>If<br>{{c1::\\(T(n) = aT(\\left \\lceil \\frac{n}{b} \\right \\rceil) + O(n^d)\\)::theorem}}<br>for some constants \\(a {\\gt} 0\\), \\(b {\\gt} 1\\), and \\(d\\geq0\\), then:<br><br>\\(\\begin{equation}\nT(n) = \\left\\{\n \\begin{array}{ll}\n {{c2::O(n^d)}} &amp; \\text{if } {{c5::d \\gt \\log_b a}} \\\\\n {{c3::O(n^d \\log n)}} &amp; \\text{if } {{c5::d = \\log_b a}} \\\\\n {{c4::O(n^{\\log_ba})}} &amp; \\text{if } {{c5::d \\lt \\log_b a}}\n \\end{array}\n\\right.\n\\end{equation}\\)<br>",
                        ""
                    ],
                    "guid": "da6_~(~CyI",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2>In the divide and conquer master theorem:<br>\\(T(n) = aT(\\left \\lceil n/b \\right \\rceil) + O(n^d)\\)<br>there are {{c1::<i>a</i>}} subproblems of size {{c1::<i>n/b</i>}}&nbsp;and combining the answers takes {{c1::\\(O(n^d)\\)}} time.",
                        ""
                    ],
                    "guid": "DrDnKqJ-,z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6 The fast Fourier transform</h3>\nThe product of two degree-d polynomials is a polynomial of degree {{c1::2d}}.  ",
                        "For example:<br>\\((1 + 2x + 3x^2)\\cdot(2 + x + 4x^2) = 2 + 5x + 12x^2 + 11x^3 + 12x^4\\)"
                    ],
                    "guid": "Liw5M}x^3=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6 The fast Fourier transform</h3>\n<p>If \\(A(x) = a_0 + a_1 x + \\cdots + a_d x^d\\)<br>and&nbsp;\\(B(x) = b_0 + b_1 x + \\cdots + b_d x^d\\),<br>their product \\(C(x) = A(x) \\cdot B(x) = c_0 + c_1 x + \\cdots + c_{2d} x^{2d}\\)<br>has coefficients:<br>\\(c_k = {{c1::a_0 b_k + a_1 b_{k−1} + · · · + a_k b_0}} = {{c2::\\sum_{i=0}^{k} a_i b_{k−i} }}\\)<br></p>",
                        "For \\(i &gt; d\\), take \\(a_i\\) and \\(b_i\\) to be zero."
                    ],
                    "guid": "j2ByCf4Xj/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials<br></h3>\n<p>A degree-d polynomial is uniquely characterized by {{c1::its values at any d + 1 distinct points}}.<br></p>",
                        ""
                    ],
                    "guid": "p4iYg}M^R,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials<br></h3>\n<p>Fix any distinct points \\(x_0 , \\cdots , x_d\\) . We can specify a degree-d<br>polynomial \\(A(x) = a_0 + a_1 x + \\cdots + a_d x^d\\) by either one of the following:<br><ol><li>{{c1::Its coefficients \\(a_0 , a_1 , \\cdots , a_d\\)}}</li><li>{{c1::The values \\(A(x_0), A(x_1), \\cdots , A(x_d)\\)}}</li></ol></p>",
                        ""
                    ],
                    "guid": "mhZ!q,2@nq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials</h3><p>Since the product C(x) has degree 2d, it is completely determined by {{c1::its value at any \\(2d + 1\\) points}}.<br></p>",
                        ""
                    ],
                    "guid": "jy@TT3&+ej",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials</h3><p>In polynomial multiplication, the value of C(z) at any given point z is {{c1::A(z) times B(z)}}.<br></p>",
                        ""
                    ],
                    "guid": "m(I$/z:9N0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials</h3><p>We expect the input polynomials, and also their product, to be specified by {{c1::coefficients}}.<br></p>",
                        ""
                    ],
                    "guid": "g467?gtV!]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials</h3><p></p><ul><li>Input: Coefficients of two polynomials, A(x) and B(x), of degree d</li><li>Output: Their product C = A · B</li></ul><p></p><h4>The basic steps for polynomial multiplication are:</h4><ol><li>Selection</li><ol><li>{{c1::Pick some points \\(x_0 , x_1 , \\cdots , x_{n−1}\\) , where \\(n \\geq 2d + 1\\)}}</li></ol><li>Evaluation</li><ol><li>{{c2::Compute \\(A(x_0), A(x_1), \\cdots , A(x_{n−1})\\) and \\(B(x_0), B(x_1), \\cdots , B(x_{n−1})\\)}}</li></ol><li>Multiplication</li><ol><li>{{c3::Compute \\(C(x_k) = A(x_k)B(x_k)\\) for all \\(k = 0, \\cdots , n−1\\)}}</li></ol><li>Interpolation</li><ol><li>{{c4::Recover \\(C(x) = c_0 + c_1x + \\cdots + c_{2d} x^{2d}\\)}}</li></ol></ol><p></p>",
                        ""
                    ],
                    "guid": "yym`tg7s0n",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.1 An alternative representation of polynomials</h3><ul><li>Input: Coefficients of two polynomials, A(x) and B(x), of degree d</li><li>Output: Their product C = A · B</li></ul><h4>The basic steps for polynomial multiplication are:</h4><ol><li>{{c1::Selection}}</li><li>{{c1::Evaluation}}</li><li>{{c1::Multiplication}}</li><li>{{c1::Interpolation}}</li></ol>",
                        ""
                    ],
                    "guid": "mv7H+/]LWQ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>If we choose positive-negative pairs,<br>\\(\\pm x_0 , \\pm x_1, \\cdots , \\pm x_{n/2−1}\\) ,<br>then the computations required for each \\(A(x_i)\\) and \\(A(−x_i)\\) overlap a lot, because the {{c1::even powers of \\(x_i\\) coincide with those of \\(−x_i\\)}}.<br></p>",
                        ""
                    ],
                    "guid": "f^1!5#b?lE",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>We need to split A(x) into its odd and even powers, for instance<br>\\(3 + 4x + 6x^2 + 2x^3 + x^4 + 10x^5 = {{c1::(3 + 6x^2 + x^4 ) + x(4 + 2x^2 + 10x^4 )}}\\).<br></p>",
                        ""
                    ],
                    "guid": "i:Oc]zbqM_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>Generally,&nbsp;\\(A(x) = {{c1::A_e(x^2) + xA_o(x^2)}}\\),<br>where \\(A_e(\\cdot)\\), with the even-numbered coefficients, and \\(A_o(\\cdot)\\), with the odd-numbered coefficients, are polynomials of degree \\(\\leq n/2 − 1\\).<br></p>",
                        "Assume for convenience that n is even."
                    ],
                    "guid": "HkM8gEkWNu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>Given&nbsp;paired points \\(\\pm x_i\\), the calculations needed for \\(A(+x_i)\\) can be recycled toward computing \\(A(−x_i)\\):<br></p><ul><li>\\(A(+x_i) = {{c1::A_e(x_i^2) + x_i A_o(x_i^2)}}\\)</li><li>\\(A(−x_i) = {{c1::A_e(x_i^2) − x_i A_o(x_i^2)}}\\)</li></ul><p></p>",
                        "In other words, evaluating A(x) at n paired points \\(\\pm x_0, \\cdots , \\pm x_{n/2−1}\\) reduces to evaluating \\(A_e(x)\\) and \\(A_o(x)\\) (which each have half the degree of A(x)) at just n/2 points, \\(x_0^2 , \\cdots , x_{n/2−1}^2\\) ."
                    ],
                    "guid": "N)C<kT|4!W",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>The complex <i>n</i>th roots of unity are&nbsp;the <i>n</i> complex solutions to the equation {{c1::\\(z^n = 1\\)}}.</p>",
                        ""
                    ],
                    "guid": "p#$]Q0$&QX",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>The <i>n</i>th roots of unity are the complex numbers \\(1, \\omega, \\omega^2 , \\cdots , \\omega^{n−1}\\) , where \\(\\omega = {{c1::e^{2πi/n} }}\\).</p><p>If n is even:<br></p><ol><li>The nth roots are plus-minus paired, \\({{c2::\\omega^{n/2+j}::in\\ terms\\ of\\ n,j}} = {{c3::−\\omega^j}}\\).</li><li>Squaring them produces {{c4::the (n/2)nd roots of unity}}.</li></ol>",
                        ""
                    ],
                    "guid": "QzCnK<n^QZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>The complex plane</p><p><img src=\"Complex_number_illustration.svg\"><br></p><p>\\(z = {{c1::a + bi}}\\) is plotted at position \\((a,b)\\).</p><p>To translate z to polar coordinates:</p><p></p><ol><li>Rewrite: \\(z(r, \\theta) = {{c2::r(\\cos \\theta + i \\sin \\theta)::using\\ trig\\ funcions}}\\)</li><li>\\(z(r, \\theta) = {{c3::re^{i \\theta} ::exponential function}}\\).</li></ol><p></p><p></p><ul><li>length \\(r(a,b) = {{c4::\\sqrt{a^2 + b^2} }}\\).</li><li>angle&nbsp;\\(\\theta \\in [0, 2\\pi): \\cos \\theta = {{c5::a/r}}, \\sin \\theta = {{c5::b/r}}\\)&nbsp;(in terms of a, b, r).</li><li>\\(\\theta\\) can always be reduced {{c6::modulo \\(2 \\pi\\)}}.</li></ul><p></p>",
                        ""
                    ],
                    "guid": "n?76WQV[!i",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>The complex plane</p><p><img src=\"Complex_number_illustration.svg\"><br></p><p>\\(z = a + bi\\) is plotted at position \\((a,b)\\).</p><p>\\(\\begin{array}{c|ccc}\nNumber &amp; -1 &amp; i &amp; 5 + 5i \\\\\n\\hline \nPolar\\ coords &amp; {{c1::(1, \\pi)}} &amp; {{c2::(1, \\pi / 2)}} &amp; {{c3::(5 \\sqrt 2, \\pi / 4)}}\\\\\n\\end{array}\\)<br></p>",
                        ""
                    ],
                    "guid": "bh9MNA$k9}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>Multiplying in polar coordinates</p><p><img src=\"paste-352d3d7fa43bb11d000759befcecbd86db48c8d3.jpg\"><br></p><p>\\((r_1 , \\theta_1) \\times (r_2 , θ_2 ) = {{c1::(r_1 r_2, θ_1 + θ_2 )}}\\).</p>",
                        ""
                    ],
                    "guid": "<L_((;%d;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>Multiplying in polar coordinates</p><p><img src=\"paste-352d3d7fa43bb11d000759befcecbd86db48c8d3.jpg\"><br></p><p>For any \\(z = (r, \\theta)\\),<br></p><ul><li>\\(−z = {{c1::(r, \\theta + \\pi)}}\\) since \\(−1 = (1, \\pi)\\).</li><li>If <i>z</i> is on the unit circle (i.e., r = 1), then \\(z^n = {{c2::(1, n\\theta)}}\\).</li></ul><p></p>",
                        ""
                    ],
                    "guid": "uMy~G]u9k<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.2 Evaluation by divide-and-conquer<br></h3><p>The <i>n</i>th complex roots of unity</p><p><img src=\"paste-b85c8ad5977f29296812749f4181a1c440e5df0f.jpg\"><br></p><p>Solutions to the equation {{c1::\\(z^n = 1\\)}}.</p><p>By the multiplication rule: solutions are \\(z = (1, \\theta)\\), for θ a multiple of \\(2\\pi/n\\) (shown here for n = 16).<br></p><p>For even <i>n</i>:<br></p><ul><li>These numbers are plus-minus paired: \\(−(1, {{c2::\\theta}}) = {{c3::(1, \\theta+\\pi)}}\\).</li><li>Their squares are the {{c4::(n/2)}}nd roots of unity, shown here with boxes around them.</li></ul><p></p>",
                        ""
                    ],
                    "guid": "yU]c7[z*0Y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.3 Interpolation<br></h3><p>The FFT is a way to move from coefficients to values in time just \\(O({{c1::n \\log n}})\\), when the points \\(\\{x_i\\}\\) are {{c2::complex nth roots of unity \\((1, \\omega, \\omega^2 , \\cdots , \\omega^{n−1})\\)}}.<br></p>",
                        ""
                    ],
                    "guid": "ndgVVX-[z;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>2.6.3 Interpolation<br></h3><p>\\(\\langle values \\rangle = {{c1::FFT(\\langle coefficients \\rangle, \\omega_n)}}\\)<br></p><p>\\(\\langle coefficients \\rangle = {{c1::\\frac 1 n FFT(\\langle values \\rangle, \\omega_n^{-1})}}\\)<br></p>",
                        "\\(\\omega_n\\) is the nth root of unity, not an index."
                    ],
                    "guid": "u[)mz~Ee}&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide-and-conquer algorithms</h2><h3>What is Euler's formula?</h3>",
                        "\\(e^{ix} = \\cos x + i \\sin x\\)<br><br>When&nbsp;\\(x&nbsp;= \\pi\\), Euler's formula evaluates to \\(e^{i\\pi}&nbsp;+ 1 = 0\\), which is known as&nbsp;Euler's identity."
                    ],
                    "guid": "efj+sZ>2*D",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide and Conquer<br></h2><h3>Multiply black box</h3><ul><li>Inputs: {{c1::Positive integers x and y, in binary}}<br></li><li>Outputs: {{c2::Their product}}<br></li><li>Runing time: {{c3::\\(O(n^{\\log_2 3})\\)}}</li><li>Method: {{c4::Gauss' trick of rearranging input halves so there are only 3 multiplication operations on n/2 input}}</li></ul>",
                        "\\(x_L y_R + x_R y_L = (x_L+x_R)(y_L+y_R) − x_Ly_L − x_Ry_R\\)"
                    ],
                    "guid": "c8akM?JQI,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide and Conquer<br></h2><h3>Fast Select black box</h3><ul><li>Inputs: {{c1::A an unsorted array, and k}}<br></li><li>Outputs: {{c2::the kth smallest element of A}}<br></li><li>Runing time: {{c3::\\(O(n)\\)}}</li><li>Method: {{c4::Finding a good pivot \\(O(\\frac n5)\\) guarantees that the subproblem is at most \\(O(\\frac34 n)\\) and the sum is less than 1.}}</li></ul>",
                        ""
                    ],
                    "guid": "Bk-diM&X,z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide and Conquer<br></h2><h3>Merge Sort black box</h3><ul><li>Inputs: {{c1::<i>A</i> an unsorted array}}<br></li><li>Outputs: {{c2::<i>A</i> sorted}}<br></li><li>Runing time: {{c3::\\(O(n \\log n)\\)}}</li><li>Method: {{c4::Combining two sorted lists into a new sorted list takes n time}}</li></ul>",
                        ""
                    ],
                    "guid": "v-t|nA/u59",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Divide and Conquer<br></h2><h3>Binary Search black box</h3><ul><li>Inputs: {{c1::<i>A</i> sorted array, <i>v</i> a desired value}}<br></li><li>Outputs: {{c2::Index of <i>v</i>}}<br></li><li>Runing time: {{c3::\\(O(\\log n)\\)}}</li><li>Method: {{c4::Dividing A in half at each step and ignoring the unused half}}</li></ul>",
                        ""
                    ],
                    "guid": "hGr7J3icNw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "divide_conquer",
                        "exam1"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f5b1cb8-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "DP",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic Programming Approach<br></h2><ol><li>{{c1::Find the <b>subproblem</b>}}</li><li>{{c1::Find the <b>recurrence</b>}}</li><ol><li>{{c1::Base Case}}</li><li>{{c1::Recurrence}}</li></ol><li>{{c1::<b>Pseudocode</b> for algorithm}}</li><li>{{c1::<b>Analyze</b> the runtime}}</li></ol>",
                        ""
                    ],
                    "guid": "Juvw3{.[YR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "DP",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.2 Longest increasing subsequence</h3><ul><li>Table entries: {{c1::L(i)&nbsp;is the length the longest increasing subsequence ending at i}}</li><li>Recurrence: {{c2::\\(L(i) = 1 + \\max_j \\{L(j) : a[j] {\\lt} a[i] \\land j {\\lt} i\\}\\)}}</li><li>Runtime: {{c3::\\(O(n^2)\\)}}</li></ul><p></p>",
                        ""
                    ],
                    "guid": "p4?Vp~M&M#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.3 Edit distance<br></h3><ul><li>Table entries:&nbsp;{{c1::E(i, j) is the edit distance between x[1..i] and y[1..j].}}</li><li>Recurrence:&nbsp;{{c2::\\(E(i, j) = \\min \\{1 + E(i − 1, j), 1 + E(i, j − 1), diff(i, j) + E(i − 1, j − 1)\\}\\)}}</li><li>Runtime: {{c3::\\(O(mn)\\)}}</li></ul><p>A function <i>diff(i, j)</i> is defined to be 0 if x[i] = y[j] and 1 otherwise.</p>",
                        ""
                    ],
                    "guid": "lJ>9XAUcU,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.4 Knapsack with repetition<br></h3><ul><li>Table entries:&nbsp;{{c1::K(b) = maximum value achievable with a knapsack of \\(weight \\leq b\\).}}</li><li>Recurrence:&nbsp;{{c2::\\(&nbsp; K(b) = \\max_i \\{K(b-w_i) + v_i : 1 \\leq i \\leq n, w_i \\leq b\\} \\)}}</li><li>Runtime: {{c3::\\(O(nB)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "f.!1>nv#^$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.4 Knapsack without repetition<br></h3><ul><li>Table entries:&nbsp;{{c1::K(i, b) = maximum value achievable using a subset of objects \\(1, \\dots , i\\) and a total weight \\(\\leq b\\).}}</li><li>Recurrence:&nbsp;{{c2::\\( K(i, b) = \\max \\{v_i + K(i-1, b-w_i), K(i-1, b) \\} \\)}}</li><li>Runtime: {{c3::\\(O(nB)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "K=`|e;@-R|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.5 Chain matrix multiplication<br></h3><ul><li>Table entries:&nbsp;{{c1::C(i, j) = minimum cost of multiplying \\(A_i \\times A_{i+1} \\times \\dots \\times A_j\\).}}</li><li>Recurrence:&nbsp;{{c2::\\(&nbsp;C(i, j) = min_l \\{C(i, l) + C(l + 1, j) + m_{i−1} \\cdot m_l \\cdot m_j : i \\leq l \\lt j \\} \\)}}</li><li>Runtime: {{c3::\\(O(n^3)\\)}}</li></ul>",
                        "Loop on s being the subproblem size."
                    ],
                    "guid": "x{T,s0a;NJ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.6 Shortest paths<br></h3><h4>All-pairs shortest paths - Floyd-Warshall algorithm</h4><ul><li>Table entries: {{c1::dist(i, j, k) denotes the length of the shortest path from i to j in which only nodes {1, 2, . . . , k} can be used as intermediates.}}</li><li>Recurrence:&nbsp;{{c2::\\(dist(i, j, k) = min \\{dist(i, k, k − 1) + dist(k, j, k − 1), dist(i, j, k − 1)\\} \\)}}</li><li>Runtime: {{c3::\\(O(|V|^3)\\)}}</li></ul>",
                        "Loop on k, i, j"
                    ],
                    "guid": "nlf_w8}*H7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.6 Shortest paths<br></h3>\n<h4>\n  The traveling salesman problem\n</h4>\n<ul><li>Table entries:&nbsp;{{c1::C(S, j) be the length of the shortest path visiting each node in S exactly once, starting at 1 and ending at j.}}</li><li>Recurrence:&nbsp;{{c2::\\(C(S, j) = \\min_{i \\in S:i \\neq j} C(S − \\{j\\}, i) + d_{ij}\\)}}</li><li>Runtime: {{c3::\\(O(n^22^n)\\)}}</li></ul>",
                        "\\(S − \\{j\\}\\) indicates set subtraction."
                    ],
                    "guid": "j&:6jUbvQ[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.7 Independent sets in trees</h3>\n<ul><li>Table entries:&nbsp;{{c1::I(u) = size of largest independent set of subtree hanging from u.}}</li><li>Recurrence:&nbsp;{{c2::\\(I(u) = \\max \\left \\{1 + \\sum_{grandchildren\\ w\\ of\\ u} I(w), \\sum_{children\\ w\\ of\\ u} I(w) \\right \\}\\)}}</li><li>Runtime: {{c3::\\(O(|V| + |E|)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "A57n3dV!9a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1",
                        "leech"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>Fibonacci</h3>\n<ul><li>Table entries:&nbsp;{{c1::T[i] is the ith Fibonacci number.}}</li><li>Recurrence:&nbsp;{{c2::\\(T[i] = T[i-1] + T[i-2]\\)}}</li><li>Runtime: {{c3::\\(O(n)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "A,;:z68_#2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>Longest Common Subsequence</h3>\n<ul><li>Table entries:&nbsp;{{c1::T[i, j] is the length of the longest common subsequence in x[1..i] and y[1..j]}}</li><li>Recurrence:&nbsp;{{c2::\\(\\begin{equation}\n&nbsp; T(i, j) = \n&nbsp; \\left\\{\n&nbsp;&nbsp;&nbsp; \\begin{array}{ll}\n&nbsp; &nbsp; &nbsp; 1+ T[i-1, j-1] &amp; x[i] = y[j] \\\\\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \\max\\{T[i-1, j], T[i, j-1]\\} &amp; x[i] \\neq y[j]\n&nbsp;&nbsp;&nbsp; \\end{array}\n&nbsp; \\right.\n\\end{equation}\\)}}</li><li>Runtime: {{c3::\\(O(n^2)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "zW$+20Cte(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Algorithms</h1><h2>Dynamic programming<br></h2><h3>6.6 Shortest paths<br></h3><h4>Shortest Path (Single Source) - Bellman-Ford</h4><ul style=\"font-weight: 400;\"><li>Table entries:&nbsp;{{c1::T[i, z] = length of shortest path from s to z using \\(\\leq i\\) edges.}}</li><li>Recurrence:&nbsp;{{c2::\\(T[i, z] = \\min \\{ T[i-1, z], \\min_y \\{ T[i-1, y] + w(y,z): for\\ (y, z) \\in E \\}\\}\\) }}</li><li>Runtime: {{c3::\\(O(|V| |E|)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "wil,Q<Ywh!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "dynamic_programming",
                        "exam1"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f5cde54-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "completeDigraph.svg",
                "dfs_labeled.svg",
                "dfs_unlabeled.svg",
                "directedBackEdge.svg",
                "graphviz.svg",
                "identifySCC_sccs.svg",
                "identifySCCa.svg",
                "identifySCCq.svg",
                "metagraph.svg",
                "scc_example.svg",
                "scc_source.svg",
                "typesOfEdges.svg"
            ],
            "name": "GR1: Strongly Connected Components",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c1::DFS}} Algorithm</p><ul><li>Input: {{c2::undirected or directed \\(G = (V, E)\\)}}</li><li>Output:</li><ul>{{c3::<li>\\(prev[z]\\): the parent index of vertex \\(z\\) in the DFS visitation</li><li>\\(pre[z]\\): the pre-order number of vertex \\(z\\) in the DFS visitation (not used)</li><li>\\(post[z]\\): the post-order number of vertex \\(z\\) in the DFS visitation</li><li>\\(ccnum[z]\\): the connected components number of vertex \\(z\\) (mostly useful in undirected graphs or in SCC algorithm to find connected components)</li>}}</ul><li>Running Time: {{c4::\\(O(n+m)\\)}}</li></ul>",
                        "DFS optionally allows providing a start vertex or a specific order for the&nbsp;vertex list \\(V\\)(as in the SCC algorithm)."
                    ],
                    "guid": "BOf<Mz(?7c",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What is/are the output(s) of depth-first search (DFS)?</p>",
                        "<ul><li>\\(prev[z]\\): the parent index of vertex \\(z\\) in the DFS visitation</li><li>\\(pre[z]\\): the pre-order number of vertex \\(z\\) in the DFS visitation (not ever used in this course)</li><li>\\(post[z]\\): the post-order number of vertex \\(z\\) in the DFS visitation</li><li>\\(ccnum[z]\\): the connected components number of vertex \\(z\\) (useful for determining strongly connected components on an undirected graph \\(G\\) or used in the SCC algorithm on a directed graph \\(G\\))</li></ul>"
                    ],
                    "guid": "xIRD{eZPeI",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What is/are&nbsp;the output(s) of breadth-first search (BFS)?</p>",
                        "<ul><li>\\(dist[u]\\): the distance from \\(s\\) to \\(u\\) if \\(u\\) is reachable from \\(s\\), otherwise \\(infinity\\)</li><li>\\(prev[z]\\): the parent index of vertex \\(z\\)</li></ul>"
                    ],
                    "guid": "zxzjiH,Lq/",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c1::BFS}} Algorithm</p><ul><li>Input:</li><ul>{{c2::<li>undirected or directed \\(G = (V, E)\\)</li><li>start vertex \\(s \\in V\\) </li>}}</ul><li>Output:</li><ul>{{c3::<li>\\(dist[u]\\): the distance from \\(s\\) to \\(u\\) if \\(u\\) is reachable from \\(s\\), otherwise \\(infinity\\)</li><li>\\(prev[z]\\): the parent index of vertex \\(z\\)</li>}}</ul><li>Running Time: {{c4::\\(O(n+m)\\)}}</li></ul>",
                        "The <em>prev</em>&nbsp;array can be used to reconstuct the path of minimum length (# of edges) from&nbsp;\\(s\\)&nbsp;to&nbsp;\\(z\\)"
                    ],
                    "guid": "J$33Ns+e(c",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Types and Properties of Edges</h2><p>&nbsp;(\\(x \\to y\\))</p><ul><li>{{c1::Tree Edges}}:</li><ul><li>description: {{c2::edges of a DFS tree; explored edges}}</li><li>post-order property: {{c2::\\(post[x] {\\gt} post[y]\\); post[parent] &gt; post[child]}}</li></ul><li>{{c1::Back Edges}}:</li><ul><li>description: {{c3::edges that go from descendant to ancestor; edges that go back up the tree}}</li><li>post-order property: {{c3::\\(post[x] {\\lt} post[y]\\); post[ancesctor] &lt; post[descendent]}}</li></ul><li>{{c1::Forward Edges}} (only exist in directed graphs):</li><ul><li>description: {{c4::edges that go from ancestor&nbsp;to descendant; edges that go down multiple depths of the tree}}</li><li>post-order property: {{c4::\\(post[x] {\\gt} post[y]\\); post[ancestor] &gt; post[descendant]}}</li></ul><li>{{c1::Cross Edges}} (only exist in directed graphs):</li><ul><li>description: {{c5::edges that have no ancestor or descendant relationship}}</li><li>post-order property: {{c5::\\(post[x] {\\gt} post[y]\\)}}</li></ul></ul>",
                        "<!--\ndigraph {\n    B -> A;\n    A -> D;\n    D -> E;\n    E -> G;\n    D -> H;\n    B -> C;\n    C -> F;\n    E -> A [color = blue];\n    F -> B [color = blue];\n    B -> E [color = red];\n    D -> G [color = red];\n    F -> H [color = cyan];\n    H -> G [color = cyan];\n}\n-->\n<i>hint</i>: \"<u>back</u> edges have <u>back</u>wards post-order numbers\"<br><br><i>GR1.8<br></i>Image shows types of edges. Starting from B and doing DFS in alphabetical order:<br><ul><li>Black: tree edges</li><li>Blue: back edges</li><li>Red: forward edges</li><li>Cyan: cross edges</li></ul><img src=\"typesOfEdges.svg\"><br><br>"
                    ],
                    "guid": "d+|-WLc=7w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c1::Dijkstra's}} Algorithm</p><ul>\n  <li>Input:</li><ul>{{c2::<li>undirected or directed \\(G = (V, E)\\)</li><li>vertex \\(s \\in V\\)</li><li><u>positive</u> edge weights \\(w_e\\)</li>}}</ul>\n  <li>Output:</li>\n  <ul>{{c3::<li>\\(dist[u]\\): the distance/cost from \\(s\\) to \\(u\\) if \\(u\\) is reachable from \\(s\\), otherwise&nbsp;<em>infinity</em></li><li>\\(prev[z]\\): the parent index of vertex \\(z\\) </li>}}</ul><li>Running Time: {{c4::\\(O((n+m) \\ log \\ n)\\)}}</li></ul>",
                        "<ul><li>Use this for non-negative, weighted single-source shortest path (SSSP).</li><li>If weights are involved, you cannot get a \\(O(n+m)\\) algorithm because the introduction of weights to any problem adds work to the algorithm.</li></ul>"
                    ],
                    "guid": "mv$2CSyTDm",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c2::Topological Sort}} Algorithm</p><ul><li>Input:</li><ul><li>{{c1::directed acyclic \\(G = (V, E)\\)}}</li></ul><li>Output:</li><ul><li>{{c3::\\(topo[i]\\): the vertex number of the \\(i\\)'th vertex in topological order from left to right, source to sink (in descending post-order numbers)}}</li></ul><li>Running Time: {{c4::\\(O(n+m)\\)}}</li></ul>",
                        "<ul><li>This algorithm works by running DFS on the DAG&nbsp;\\(O(n+m)\\) and using the post-order number to populate the vertices in the&nbsp;\\(topo[ \\ ]\\) array from highest post-order number to lowest post-order number \\(O(n)\\).</li><li>When a DAG is ordered from source to sink, then all edges go from left to right.</li></ul>"
                    ],
                    "guid": "xJ@o/it[x)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>A {{c1::<u>source vertex</u>}} is {{c2::a vertex with <u>no incoming edges</u> (only has outgoing edges)}}.</p>",
                        "<ul><li>The vertex with the highest post-order number in a DAG or topological sort order&nbsp;is guarenteed to be a source vertex.</li><li>Every topological ordering must have a source&nbsp;vertex as its first vertex.</li><li>A DAG always has at least one source vertex.</li></ul>"
                    ],
                    "guid": "D&?r!%l8j",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>A {{c1::<u>sink vertex</u>}} is {{c2::a vertex with <u>no outgoing edges</u> (only has incoming edges)}}.</p>",
                        "<ul><li>The vertex with the lowest post-order number in a DAG or topological sort order (but not a general directed graph) is guarenteed to be a sink vertex.</li><li>Every topological ordering must have a sink vertex as its last vertex.</li><li>A DAG always has at least one sink vertex.</li></ul>"
                    ],
                    "guid": "L#-6ip08u,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Strongly Connected Components</h2><p>What does it mean for vertices \\(v\\) and \\(w\\) to be <u>strongly connected</u>?</p>",
                        "\\(v\\) and \\(w\\) are strongly connected if there is a <u>path</u> \\(v \\to w\\) and a <u>path</u> \\(w \\to v\\)<br><br>Vertices \\(A\\) and \\(C\\) are <u>strongly connected</u> (so are \\(A\\) and \\(B\\), \\(B\\) and \\(C\\))<br><img src=\"scc_example.svg\">"
                    ],
                    "guid": "Hf_Wll7SZ7",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How many edges (asymptotically) are in a <u>fully-connected</u>&nbsp;undirected graph (or <i>complete graph</i>)?</p>",
                        "\\(|E|=|V|^2\\)"
                    ],
                    "guid": "vfo(cwi&HL",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What does it mean for a <u>directed</u> graph to be <u>fully-connected</u>&nbsp;(<i>complete graph</i>)?</p>",
                        "<!--\ndigraph {\n    node[shape=point]\n    subgraph cluster_0{\n      a0->b0\n      b0->a0\n    }\n  \n    subgraph cluster_1{\n      a1->b1\n      a1->c1\n      b1->a1\n      b1->c1\n      c1->a1\n      c1->b1\n    }\n    \n    subgraph cluster_2{\n      a2->b2\n      a2->c2\n      a2->d2\n      b2->a2\n      b2->c2\n      b2->d2\n      c2->a2\n      c2->b2\n      c2->d2\n      d2->a2\n      d2->b2\n      d2->c2\n    }\n}\n-->\nA <u>directed</u> graph is&nbsp;<u>fully-connected</u>&nbsp;if each vertex is directly connected to every other vertex (an edge exists between every pair of vertices).<br><br>\\(|E|=|V|^2\\)<br><br>This is also known as a <i>complete graph</i>.<br><br><i>examples</i><br><br><img src=\"completeDigraph.svg\">"
                    ],
                    "guid": "oC49hx-tp]",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How do you get connected components in an <u>undirected</u> graph \\(G\\)?</p>",
                        "Run DFS and keep track of the connected component numbers (\\(ccnum[ \\ ]\\))<br><br><br>If \\(ccnum[z] = ccnum[u]\\), they are in the same connected component.<br>If \\(ccnum[z] \\ne ccnum[u]\\), they are in different connected components.<br><br>This does not apply in a directed graph.<br><br><i>Lecture GR1.3</i>"
                    ],
                    "guid": "e8fi}>Ux7q",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How do you find a path between two connected vertices (x,y) using DFS?</p>",
                        "Supply DFS with starting point <em>x</em>. Backtrack from <em>y</em>&nbsp;to <em>x</em>&nbsp;using the \\(prev[v]\\) array."
                    ],
                    "guid": "Q1Z~;da1Aq",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How can DFS be modified to find ordering info for a <u>directed</u> graph \\(G\\)?</p>",
                        "Add pre-order (not actually used) and post-order numbers.<br>\n<code>DFS(G):\n  clock = 1\n  for all v in V, visited(v) = FALSE\n  for all v in V,\n    if not visited(v) then Explore(v)\n\nExplore(z):\n  pre(z) = clock; clock++\n  visited(z) = TRUE\n  for all (z,w) in E:\n    if not visited(w) then Explore(w)\n  post(z) = clock; clock++\n</code>"
                    ],
                    "guid": "fJJ4W8#C}a",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>Run the DFS algorithm on the following graph starting from B, drawing the DFS tree with pre-order and post-order labels for each node.</p><p><img src=\"dfs_unlabeled.svg\"><br></p>\n<!--\ndigraph G {\n  B [fillcolor = lightgreen, style=filled]\n  A->D\n  B->A\n  B->E\n  B->C\n  C->F\n  D->E\n  D->G\n  E->A\n  E->G\n  E->H\n  F->B\n  F->H\n  H->G\n}\n-->",
                        "<img src=\"dfs_labeled.svg\"><br>(pre-order number, post-order number)\n<!--\ndigraph G {\n  B [fillcolor = lightgreen, style=filled]\n  A [label=\"A (2,11)\"]\n  B [label=\"B (1,16)\"]\n  C [label=\"C (12,15)\"]\n  D [label=\"D (3,10)\"]\n  E [label=\"E (4,9)\"]\n  F [label=\"F (13,14)\"]\n  G [label=\"G (5,6)\"]\n  H [label=\"H (7,8)\"]\n  A->D\n  B->A\n  B->E\n  B->C\n  C->F\n  D->E\n  D->G [style=dashed]\n  E->A [style=dashed]\n  E->G\n  E->H\n  F->B [style=dashed]\n  F->H [style=dashed]\n  H->G [style=dashed]\n}\n-->"
                    ],
                    "guid": "ej5[ODFz)&",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>What does the <u>pre-order</u> number of a vertex represent?",
                        "The value of the \\(clock\\) when we first explore the vertex.<br><br>We don't have a use for this number in this course. When lectures or materials in this course refer to the \"order number\", they mean the post-order number."
                    ],
                    "guid": "kBM^D+-OKO",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>What does the <u>post-order</u> number of a vertex represent?",
                        "The value of the \\(clock\\) when we finish exploring the vertex.<br><br>The post-order number also determines the placement of the vertex in the topologically sorted order."
                    ],
                    "guid": "FH%|ky3D9>",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>Based on the DFS tree of \\(G\\), how can you tell if \\(G\\) has a <u>cycle</u>?",
                        "\\(G\\) has a cycle if and only if its DFS tree has a <u>back edge</u>.<br><br><i>Lecture: GR1.9</i>"
                    ],
                    "guid": "u$MB)<cz-h",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><br>A DFS tree can be a <u>forest</u>.<br><br><i>True</i>&nbsp;or&nbsp;<i>False</i><br>",
                        "<i><b>True</b></i><br><br>We call it a DFS \"tree\", but it can be a forest. Yes, this is misleading."
                    ],
                    "guid": "BVDx4c%)a/",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>What is a <u>DAG</u>?",
                        "A DAG is a <u>D</u>irected, <u>A</u>cyclic <u>G</u>raph.<br><br>Acyclic means there are no cycles in the graph == no back edges."
                    ],
                    "guid": "8uMw[WJ.*",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><br>What does it mean for a graph \\(G\\) to be <u>acyclic</u>?",
                        "<u>Acyclic</u> means there are <u>no cycles</u> in the graph, therefore there are <u>no back edges</u> in the graph."
                    ],
                    "guid": "O:/}+A2.~i",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<!--\ndigraph {\n  A -> B\n  B -> C\n  B -> D\n  B -> E\n  C -> F\n  E -> B\n  E -> L\n  F -> G\n  F -> I\n  G -> F\n  G -> C\n  H -> I\n  H -> J\n  I -> J\n  J -> H\n  J -> K\n  K -> L\n  L -> I\n  \n}\n-->\n<h1>Graphs</h1>Identify the strongly-connected components in this directed graph:<br><img src=\"identifySCCq.svg\"><br>",
                        "There are <b>5</b> strongly connected components in this graph.<br><img src=\"identifySCCa.svg\"><br><img src=\"identifySCC_sccs.svg\">"
                    ],
                    "guid": "Q2Uu1~?l`}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>Topologically sorting a DAG means to {{c1::order the vertices in descending post-order numbers so that all edges go: from a higher order number vertex \\(\\to\\) a lower order number vertex}}.",
                        "Steps:<br><ol><li>Run DFS on DAG \\(G\\)&nbsp; &nbsp; &nbsp;// \\(O(n+m)\\)</li><li>Order vertices by decreasing post-order numbers&nbsp; // \\(O(n)\\)</li></ol><br>Running Time: \\(O(n+m)\\) due to dominant running time of DFS.&nbsp;<br><br><i>Lecture: GR1.10</i><br>"
                    ],
                    "guid": "Hs4Mp,Z*pT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>A DAG is guarenteed to have at least one {{c1::source vertex}} and at least one {{c1::sink vertex}}.",
                        "There <i>may</i> be more than one, but there will always be at least one source and sink vertex in each DAG."
                    ],
                    "guid": "qBIwJ2x/%M",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1>Alternative Topological Sorting Algorithm Steps<br><ol><li>{{c1::Find a sink vertex, add it to a list, and delete it.}}</li><li>{{c1::Repeat step #1 until the graph is empty.}}</li><li>{{c1::Reverse the list and output it.}}</li></ol>",
                        "Alternatively, just build the list/array backwards. This is easy when the number of vertices is known ahead of time.<br><br><i>Lecture: GR1.12</i>"
                    ],
                    "guid": "q;t{l,hb!E",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><br>In the DFS tree of a <u>directed</u> graph, a <u>back edge</u>&nbsp;can go from a child vertex to a parent vertex.<br><br><i>True</i> or <i>False</i>",
                        "<b><i>True<br></i></b><br>Consider this graph:<br><br>\\(3 \\to 2\\) is a <u>back edge</u>&nbsp;in the resulting DFS tree.<br><br><img src=\"directedBackEdge.svg\"><br>In the DFS tree of an <b>undirected</b> graph, this would be <i>false</i>. Any edge that connects a parent and child vertex in the DFS tree can only be a tree edge in an undirected graph.&nbsp;"
                    ],
                    "guid": "N+9H:osi|m",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><br>What type of <u>edges</u> exist in an <u>undirected</u> graph \\(G\\)?",
                        "<ul><li>Tree edges: Edges that are part of the DFS tree/forest.</li><li>Back edges: An edge that leads to an ancestor in the DFS tree. (these can also be referred to as non-tree edges)</li></ul><br><i>DPV 3.3.1</i>:&nbsp;<span style=\"background-color: rgb(248, 248, 248); color: rgb(29, 28, 29);\">\"for undirected graphs we distinguished between tree edges and nontree edges.&nbsp;</span><span style=\"background-color: rgb(248, 248, 248); color: rgb(29, 28, 29);\">In the directed case, there is a slightly more elaborate taxonomy\"</span>"
                    ],
                    "guid": "m$fODqc@Dc",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><br>What type of <u>edges</u> exist in a <u>directed</u> graph \\(G\\)?",
                        "<ul><li>Back edges: An edge that leads to an ancestor in the DFS tree.</li><li>Tree edges: Edges that are part of the DFS tree/forest.</li><li>Forward edges: Edges that lead from a node to a nonchild descendant in the DFS tree.</li><li>Cross edges: Edges that lead to neigher descendant nor ancestor; they therefore lead to a node that has already been completely explored (already post-visited).</li></ul>"
                    ],
                    "guid": "lPYC?aEK3}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What does it mean for an <u>undirected</u> graph to be&nbsp;<u>connected</u>?</p><h1></h1>",
                        "An <u>undirected</u> graph is&nbsp;<u>connected</u>&nbsp;if there is <u>path</u> between every pair of vertices."
                    ],
                    "guid": "x]kWvWl$GQ",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><div>What does it mean for a <u>directed</u> graph to be&nbsp;<u>strongly-connected</u>?</div>",
                        "A <u>directed</u> graph is&nbsp;<u>strongly</u><u>-connected</u>&nbsp;if a <strong>path</strong> exists between every pair of vertices."
                    ],
                    "guid": "kC`2W9@}M^",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What is a <u>metagraph</u>?</p>",
                        "<!--\ndigraph G {\n\n\tsubgraph cluster_0 {\n\t\tnode [style=filled];\n\t\tA;\n\t\tcolor=blue\n\t}\n\n\tsubgraph cluster_1 {\n\t\tnode [style=filled];\n\t\tB -> E;\n\t\tE -> B;\n\t\tcolor=blue\n\t}\n\t\n\tsubgraph cluster_2 {\n\t\tnode [style=filled];\n\t\tD;\n\t\tcolor=blue\n\t}\n\t\n\tsubgraph cluster_3 {\n\t\tnode [style=filled];\n\t\tC -> F;\n\t\tF -> C;\n\t\tcolor=blue\n\t}\n\t\n\tsubgraph cluster_4 {\n\t\tnode [style=filled];\n\t\tG -> H;\n\t\tG -> J;\n\t\tH -> K;\n\t\tI -> G;\n\t\tJ -> I;\n\t\tK -> L;\n\t\tL -> J;\n\t\tcolor=blue\n\t}\n\tA -> B;\n\tB -> D;\n\tB -> C;\n\tE -> F;\n\tE -> G;\n\tF -> H;\n}\n-->\nA <u>metagraph</u> is when a graph repesentation where you represent each SCC (strongly connected component) as a vertex.<br><br>A directed graph and its SCCs:<br><img src=\"scc_source.svg\"><br>Metagraph, showing a vertex for each SCC:<br><img src=\"metagraph.svg\"><br><i>Lecture GR1.16</i>"
                    ],
                    "guid": "tk^[B0u<KP",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>A&nbsp;<u>metagraph</u>&nbsp;is always a DAG.</p><p><i>True</i>&nbsp;or&nbsp;<i>False</i></p>",
                        "<i><b>True<br></b></i><br>If there was a cycle, meaning that some vertex is strongly connected to another vertex outside it's strongly connected component (SCC), that would break the definition of the metagraph. If a vertex is strongly connected to any other vertex, those vertices would be in the same SCC."
                    ],
                    "guid": "r`P}}wvTM;",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c2::Strongly Connected Components (SCC)}} Algorithm</p><ul><li>Input:</li><ul><li>{{c1::directed \\(G = (V, E)\\)}}</li></ul><li>Output:</li>{{c4::<ul><li>\\(G^{SCC} = (V^{SCC}, E^{SCC})\\) where \\(G^{SCC}\\) is a metagraph (DAG) with each \\(SCC\\) in \\(G\\) forming a \\(vertex \\in V^{SCC}\\) and each edge between \\(SCCs \\in E^{SCC}\\)</li><ul><li>\\(V^{SCC}\\) will look like \\([1, 2, 3, 4]\\), which represent the \\(ccnum\\) of each \\(SCC\\)<br></li>\n  <li>\\(E^{SCC}\\) will look like \\([(1, 2), (2, 3), (3, 4)]\\) which are the edges between \\(V^{SCC}\\)</li></ul><li>\\(ccnum[ \\ ]\\), which comes from the DFS output used as sub-steps in the SCC algorithm&nbsp;</li><ul><li>use \\(ccnum[ \\ ]\\) to find out which SCC each vertex (\\(v \\in V\\)) \\(\\in G\\) is in (\\(ccnum[u] = \\)&nbsp;what \\(V^{SCC}\\) vertex \\(u\\) is in) </li></ul></ul>}}<li>Running Time: {{c3::\\(O(n+m)\\)}}</li></ul>",
                        "\\(ccnum[u]\\) = what \\(V^{SCC}\\) vertex \\(u\\) is in<br><br><p><u>to build the metagraph:</u></p><ul><li>We use the \\(ccnum[ \\ ]\\) array to gather up the vertices that belong to each \\(V^{SCC}\\)&nbsp;.&nbsp;</li><li>We then iterate through the original edges and their vertices \\(G=(V,E)\\).</li><ul><li>If the endpoints of an edge are in different SCCs, and a corresponding \\(E^{SCC}\\) between those SCCs does not already exist, we add a \\(E^{SCC}\\) to represent the edge from one SCC to another.</li></ul></ul>"
                    ],
                    "guid": "L$Bo{X0QEt",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>Strongly Connected Components (SCC) Algorithm Steps</p><ol><li>{{c2::Construct \\(G^R\\) (a reverse of \\(G=(V,E)\\), you flip all the edges to reverse \\(G\\))}}</li><li>{{c3::Run DFS on \\(G^R\\)&nbsp;</li><ul><li>output: post-order numbers for each V (\\(post[ \\ ]\\)) }}</li></ul><li>{{c1::Sort \\(V\\) from \\(G=(V,E)\\) by descending post-order number that was derived from first DFS run (step #2).</li><ul><li>output: \\(V' = sorted(V)\\) by descending post-order numbers }}</li></ul><li>{{c4::Run DFS again on \\(G=(V'=sorted(V),E)\\)</li><ul><li>output: \\(ccnum[ \\ ]\\) that represents each SCC of&nbsp;\\(G\\)</li><ul><li>highest ccnum = a sink vertex in \\(G\\)<b> </b>= a source vertex in \\(G^R\\)&nbsp;</li><li>lowest ccnum = a source vertex in \\(G\\)&nbsp;&nbsp;= a sink vertex in \\(G^R\\)&nbsp;</li></ul><li>output: \\(G^{SCC}\\) the metagraph }}</li></ul></ol>",
                        "<p><u>to build the metagraph:</u></p><ul><li>We use the \\(ccnum[ \\ ]\\) array to gather up the vertices that belong to each \\(V^{SCC}\\)&nbsp;.&nbsp;</li><li>We then iterate through the original edges and their vertices \\(G=(V,E)\\).</li><ul><li>If the endpoints of an edge are in different SCCs, and a corresponding \\(E^{SCC}\\) between those SCCs does not already exist, we add a \\(E^{SCC}\\) to represent the edge from one SCC to another.</li></ul></ul><u><br>main idea of SCC algorithm<br></u><ul><li>find a <u>sink</u> SCC \\(S\\) (a node that represents a SCC in the metagraph with no outgoing edges)</li><li>output it (put it at the end of the topological ordering list)</li><li>remove it (run \\(explore(z)\\) on any vertex in the sink SCC \\(S\\), remove all the vertices that are \\(visited[v] = TRUE\\) )</li><li>and repeat until the graph is empty</li></ul>"
                    ],
                    "guid": "HpK#`|TQlU",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How do you <u>reverse</u> a graph?</p><p>\\(G \\to G^R\\)</p>",
                        "To reverse a graph \\(G\\) (transform G into \\(G^R\\)), you flip the direction of all the edges.<br><br>\\(G^R = (V,E^R) \\text{ where } E^R={\\overrightarrow{wv}:&nbsp;\\overrightarrow{vw} \\in E}\\)"
                    ],
                    "guid": "igBc,GxCAy",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Strongly Connected Components (SCC)</b></p><p>How do you <u>find</u> a vertex in a <u>sink SCC</u>?</p><p>For a general directed graph \\(G\\):</p><ol><li>{{c1::Reverse graph \\(G\\) to get \\(G^R\\) (flip all the edges) \\(G^R = (V,E^R)\\)}}</li><li>{{c1::Run DFS on \\(G^R\\)}}</li><li>{{c1::Find the \"source\" SCC in \\(G^R\\), which is the vertex with the highest post-order number}}</li></ol>",
                        "source SCC in&nbsp;\\(G^R\\)&nbsp;= sink SCC of&nbsp;\\(G\\)"
                    ],
                    "guid": "x;4GMW<SWS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Strongly Connected Components (SCC)</b></p><p>What are the steps to&nbsp;<u>find</u> a vertex in a <u>sink SCC</u>&nbsp;in a general directed graph \\(G\\)?</p>",
                        "<ol><li>Reverse graph \\(G\\) to get \\(G^R\\) (flip all the edges) \\(G^R = (V,E^R)\\)</li><li>Run DFS on \\(G^R\\)</li><li>Find the \"source\" SCC in \\(G^R\\), which is the vertex with the highest post-order number (source SCC in \\(G^R\\) = sink SCC of \\(G\\))</li></ol>"
                    ],
                    "guid": "sd}x{5#vn>",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Strongly Connected Components (SCC)</b></p><p>Relationships between source and sink SCCs in \\(G\\) and \\(G^R\\)</p><p>Source SCC in \\(G\\) = {{c1::sink}} SCC in \\(G^R\\)</p><p>Sink SCC in \\(G\\) = {{c1::source}} SCC in \\(G^R\\)</p>",
                        "To find a sink SCC in G:<br><ol><li>Reverse graph \\(G\\) to get \\(G^R\\) (flip all the edges) \\(G^R = (V,E^R)\\)</li><li>Run DFS on \\(G^R\\)</li><li>Find the \"source\" SCC in \\(G^R\\), which is the vertex with the highest post-order number (source SCC in \\(G^R\\) = sink SCC of \\(G\\))</li></ol>"
                    ],
                    "guid": "tvYSYApT1J",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>\n  In an undirected graph:\n</p><ul><li>The vertex with {{c1::the highest post-order number}} is guaranteed to be {{c2::a source vertex}}.</li><li>The vertex with {{c1::the lowest post-order number}} is guaranteed to be {{c2::a sink vertex}}.</li></ul>",
                        ""
                    ],
                    "guid": "d?+#&gB+g:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><ul><li>Every topological ordering must have {{c1::a sink vertex}} as {{c2::its last vertex}}.</li><li>Every topological ordering must have {{c1::a source&nbsp;vertex}} as {{c2::its first vertex}}.</li></ul>",
                        ""
                    ],
                    "guid": "S(:=n%@,E",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What is the <i>degree</i> \\(d(u)\\) represent in an <u>undirected</u> graph \\(G\\)?</p>",
                        "The <u>degree</u> of a vertex \\(u\\) in an <u>undirected</u> graph \\(G\\) is the number of neighbors that \\(u\\) has, or the number of edges that are connected to \\(u\\).&nbsp;"
                    ],
                    "guid": "jI{8-}x`Sb",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>How is the&nbsp;<i>degree</i>&nbsp;of a vertex \\(u\\) represented in a&nbsp;<u>directed</u> graph \\(G\\)?</p>",
                        "The <u>degree</u> of a vertex \\(u\\) in a&nbsp;<u>directed</u> graph \\(G\\) is distinguished between:<br><ul><li>the <i>indegree</i> \\(d_{in}(u)\\), which is the number of incoming edges into \\(u\\).</li><li>the <i>outgree</i> \\(d_{out}(u)\\), which is the number of outgoing edges leaving \\(u\\).</li></ul>"
                    ],
                    "guid": "H#I3XSCp>z",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>In an undirected graph \\(G\\), there must be an even number of vertices whose degree is odd.</p><p><i>True or False</i></p>",
                        "<i><b>True</b></i>"
                    ],
                    "guid": "wyR)2F7ADa",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>{{c4::Explore}} Algorithm</p><ul><li>Input:</li><ul>{{c1::<li>undirected or directed \\(G = (V, E)\\)</li><li>start vertex \\(s \\in V\\) </li>}}</ul><li>Output:</li><ul><li>{{c2::\\(visited[u]\\): whether vertex \\(u\\) is reachable from \\(s\\)}}</li></ul><li>Running Time:</li>{{c3::<ul><li>\\(O(m)\\) if run as part of DFS</li><li>\\(O(n+m)\\)&nbsp;if run on its own and \\(visited[ \\ ]\\) needs to be created</li></ul>}}</ul>",
                        ""
                    ],
                    "guid": "gk7C7o4U!t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What does \\(G^R\\) represent?</p>",
                        "The <u>reverse graph</u> used in the SCC algorithm.<br>\\(G^R=(V,E^R)\\)<br><br><br><br><i>Don't mix this up with a residual network for max-flow, represented as </i>\\(G^f.\\)<br>\\(G^f = (V,E^f)\\)"
                    ],
                    "guid": "cAR>@cU>U<",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>Every {{c1::directed graph}} is a {{c2::DAG}} of its {{c3::SCCs}}.</p>",
                        "A directed graph can be broken up into SCCs and then the SCCs can be topologically ordered because it is a DAG."
                    ],
                    "guid": "L&dgxKvwYf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Strongly Connected Components</h2>In a general directed graph, does the vertex with the <b>lowest</b> post-order number always lie in a <b>sink</b> SCC?",
                        "No.<br>For example:<br><img src=\"graphviz.svg\"><br>{a, b} form an SCC but not a sink SCC."
                    ],
                    "guid": "uNQf+/Uh~j",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Strongly Connected Components</h2>In a general directed graph, does the vertex with the <b>highest</b> post-order number always lie in a <b>source</b> SCC?<br>",
                        "Yes."
                    ],
                    "guid": "Jghv+Ia81#",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>How can you find what vertices can reach&nbsp;\\(t\\) in a directed graph&nbsp;\\(G=(V,E)\\) in linear time \\(O(n+m)\\)?</p><p><i>Note</i>: This is not asking what vertices are reachable from&nbsp;\\(t\\), it's the opposite.</p>",
                        "<ol><li>Build \\(G^R\\), a reverse of the input graph \\(G\\) (flip all the edges).</li><li>Run \\(explore(t, G^R)\\) to find what vertices are reachable from \\(t\\) in \\(G^R\\), which is the same as the vertices that can reach&nbsp;\\(t\\) in \\(G\\).</li><li>Output all vertices&nbsp;\\(v \\in V\\) where&nbsp;\\(visited[v] = true\\).</li></ol>"
                    ],
                    "guid": "J@oWzts`AY",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "max_flow",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Graphs\n</h1>\n<h2>\n  General Problems\n</h2>\n<p>\n  How would you find the single source <b>shortest</b> path on a DAG (to all other vertices)?\n</p>",
                        "Do a topological sort on V, and initialize dist[|V|] to infinity. Go through the vertices in topological order, and the edges from those vertices. If the path to v plus the weight of v to w is less than dist[w], update dist[w].<br>This is similar to Dijkstra's algorithm but the priority queue mechanism isn't needed and it can run in \\(O(n + m)\\)."
                    ],
                    "guid": "y(H>3uX/)j",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Graphs\n</h1>\n<h2>\n  General Problems\n</h2>\n<p>\n  How would you find the single source <b>longest</b> path on a DAG (to all other vertices)?\n</p>",
                        "<ol><li>Multiply all edge weights by -1.</li><li>Run the Single Source Shortest Path (on a DAG) algorithm.</li><li>Multiply all edge weights by -1.</li></ol><br>The SSSP algorithm (on a DAG) is works with positive or negative edge weights.<br>"
                    ],
                    "guid": "E|sQ|5,H/J",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What algorithms run in <u>linear time</u> \\(O(n+m)\\)?<br></p>",
                        "<ul><li>DFS(G)</li><li>BFS(s, G)</li><li>Explore(s, G) - if run on it's own (not within the context of DFS)</li><li>Topological Sort Algorithm</li><li>Strongly Connected Components (SCC) Algorithm</li><li>2SAT Algorithm</li><li>Building a graph (i.e. \\(G^R\\) and \\(G^f\\))</li></ul>"
                    ],
                    "guid": "iXG1&J;*{z",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>Why is the running time of the explore algorithm sometimes listed as&nbsp;\\(O(n+m)\\) and other times listed as&nbsp;\\(O(m)\\)?<br></p>",
                        "Explore is&nbsp;\\(O(n+m)\\) when it is run on it's own. You need to create and populate the&nbsp;\\(visited[ \\ ]\\) array in&nbsp;\\(O(n)\\) time, and then run the remainder of the algorithm.<br><br>Explore is&nbsp;\\(O(m)\\) when run as a sub-routine within the DFS algorithm, because the work related to the \\(visited[ \\ ]\\)&nbsp;array is done within the DFS algorithm."
                    ],
                    "guid": "rlf?vp3{L{",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>DFS Pseudocode Algorithm for <span style=\"color: rgb(0, 0, 255);\">undirected</span> graph</p><p>DFS(G) // undirected</p><p>\nInput G=(V,E)</p>\n<code>DFS(G):\n{{c1::cc = 0\nfor all v in V:\n\t visited[v] = FALSE\n\nfor all v in V:\n    if !visited[v]:\n\t\t  ++cc\n        Explore(v)}}\n        \n\nExplore(z):\n{{c2::ccnum[z] = cc\nvisited[z] = TRUE\nfor all (z,w) in E:\n    if !visited[w]:\n        Explore[w]}}</code>",
                        ""
                    ],
                    "guid": "ezIsl1b,SA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "pseudocode",
                        "scc"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>DFS Pseudocode Algorithm for <span style=\"color: rgb(0, 0, 255);\">directed</span> graph</p><p>DFS(G) // directed</p><p>\nInput G=(V,E)</p>\n<code>DFS(G):\n{{c1::clock = 1\nfor all v in V:\n\t visited[v] = FALSE\n\nfor all v in V:\n    if !visited[v]:\n        Explore(v)}}\n        \n\nExplore(z):\n{{c2::pre[z] = clock; clock++\nvisited[z] = TRUE\nfor all (z,w) in E:\n    if !visited[w]:\n        Explore[w]\npost[z] = clock; clock++}}</code>",
                        ""
                    ],
                    "guid": "E!j`XG=y-5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "pseudocode",
                        "scc"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f5efaf4-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "heavyNonCycleEdge-8eaf209c766dea20565eef856aaf2ec7ad4fb6fa.svg",
                "mstVsDijkstra-bfbde9ecb05beadbb30f9b30ddad76e9162b5cb1.svg"
            ],
            "name": "GR3: Minimum Spanning Tree",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Minimum Spanning Tree</h2><p>{{c2::Kruskal's}} Algorithm</p><ul><li>Input: {{c1::undirected, connected \\(G = (V, E), edge\\ weights\\ w_e\\)}}</li><li>Output: {{c4::minimum spanning tree (MST) defined by edges \\(E^{MST}\\)<sup>&nbsp;</sup>}}</li><li>Running Time: {{c3::\\(O(m\\ log\\ m)\\) or simplified to \\(O(m\\ log\\ n)\\)&nbsp;}}</li></ul>",
                        "Kruskal's algorithm is a greedy approach to MST. <br><ul><li>The approach to Kruskal's is that it sorts the edges of undirected, connected \\(G\\), grabs the lightest available edge that will not create a cycle, and inserts it into the MST. Keep doing this until all edges that will not create a cycle are added, which will be exactly n-1 edges.</li><li>This is the more common of the MST algorithms. Gives a set of edges which is useful to construct the next input for a black box, or to compare to the original \\(G\\).</li></ul><br>"
                    ],
                    "guid": "ck^=f2!zlH",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Minimum Spanning Tree</h2><p>{{c2::Prim's}} Algorithm</p><ul><li>Input: {{c1::undirected, connected \\(G = (V, E), edge\\ weights\\ w_e\\)}}</li><li>Output: {{c4::minimum spanning tree (MST) defined by the \\(prev[ \\ ]\\) array}}</li><li>Running Time: {{c3::\\(O(m\\ log\\ m)\\) or simplified to \\(O(m\\ log\\ n)\\)&nbsp;}}</li></ul>",
                        "\\(prev[z]\\): the parent index of vertex \\(z\\)<br>you must follow the parent indexes of the \\(prev[ \\ ]\\) array to reconstruct the MST<br><br>Prim's MST Algorithm is akin to Dikstra's algorithm, we don't cover it in the lecture in detail.<br><br><i>Lecture: GR3.15: Prim's Algorithm</i>"
                    ],
                    "guid": "zck%tvZgP*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "black_box",
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Properties of a Tree</h2><ul><li>{{c1::A tree on \\(n\\) vertices has exactly \\(n-1\\) edges.}}</li><li>{{c2::Exactly one path::number of paths}} exists between every pair of vertices.</li><li>{{c3::Any connected \\(G = (V, E)\\) with \\(|E| = |V| - 1\\) is a tree.}}</li></ul>",
                        "A tree is a connected, acyclic graph."
                    ],
                    "guid": "C4h93rOHPJ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>If graph&nbsp;\\(G\\) has more than&nbsp;\\(|V|-1\\) edges, and there is a unique heaviest edge, then this edge cannot be part of a minium spanning tree.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">False</i><br><br>Consider a graph where a vertex is adjacent to a single edge.<br><img src=\"heavyNonCycleEdge-8eaf209c766dea20565eef856aaf2ec7ad4fb6fa.svg\">"
                    ],
                    "guid": "O;;V-`mdu?",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>If&nbsp;\\(G\\) has a cycle with a unique heaviest edge&nbsp;\\(e\\), then&nbsp;\\(e\\) cannot be part of any MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">True</i><br><br>This is the definition of the&nbsp;<u>cycle property</u>&nbsp;of MSTs.<br><br>The&nbsp;<u>cycle property</u>&nbsp;states \"For any cycle \\(C\\) in the graph, if the weight of an edge \\(e\\) of \\(C\\) is larger than the individual weights of all other edges of \\(C\\), then this edge cannot belong to an MST\".<br><br>Consider the order in which the edges would be processed by Krushkal's.<br><br><i>Note:</i>&nbsp;Pay special attention to the word <i>unique</i>&nbsp;here. If the edge was non-unique, it isn't guarenteed to be in the MST, the order that equally-weighted edges are processed by Krushkal's is arbitrary."
                    ],
                    "guid": "e>3hWUn%K#",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>Let \\(e\\) be any edge of minimum weight in \\(G\\). Then \\(e\\) must be part of some MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">True</i><br><br>A minimum weight edge would be a candidate for at least one possible MST."
                    ],
                    "guid": "P@T;MUV=Ce",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>If the lightest edge in a graph is unique, then it must be part of every MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">True</i><br><br>The <u>cut property</u> assures this."
                    ],
                    "guid": "JJ{g%LwctK",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>If \\(e\\) is part of some MST of \\(G\\), then it must be a lightest edge across some cut of \\(G\\).</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">True</i>"
                    ],
                    "guid": "G4+:Jm0wj/",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>If \\(G\\) has a cycle with a unique lightest edge \\(e\\), then \\(e\\) must be part of every MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">True<br></i><br>This is the inverse definition of the <u>cycle property</u> of MSTs.<br><br>The <u>cycle property</u> states \"For any cycle \\(C\\) in the graph, if the weight of an edge \\(e\\) of \\(C\\) is larger than the individual weights of all other edges of \\(C\\), then this edge cannot belong to an MST\".<br><br><i>Note:</i>&nbsp;Pay special attention to the word&nbsp;<i>unique</i>&nbsp;here. If the edge was non-unique, it is may be in the MST, the order that equally-weighted edges are processed by Kruskal's is arbitrary."
                    ],
                    "guid": "bmzxi(W+g.",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>The shortest-path tree computed by Dijkstra's algorithm is necessarily an MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<!--\ngraph {\n    A--B [label=30 weight=3]\n    A--D [label=40  weight=4 color=gold penwidth=3]\n    B--C [label=35  weight=3.5]\n    C--D [label=20  weight=2]\n    C--F [label=5  weight=0.5]\n    D--E [label=2  weight=0.2]\n    D--G [label=1  weight=0.1]\n}\n-->\n<i style=\"font-weight: bold;\">False<br></i><br>The gold edge is the shortest AD path from Dijkstra's algorithm, but is the heaviest edge in a cycle.<br><img src=\"mstVsDijkstra-bfbde9ecb05beadbb30f9b30ddad76e9162b5cb1.svg\">"
                    ],
                    "guid": "iY@Zi@$(2q",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>The shortest path between two nodes is necessarily part of some MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i style=\"font-weight: bold;\">False<br></i>Imagine a triangle of nodes A, B, C. AB = 3, AC = 3, BC = 4. The shortest BC path is directly with a cost of 4 (the other path being BA + AC for a cost of 6). But AB and AC create an MST."
                    ],
                    "guid": "kaIE8-idMG",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Tree Problem</b></p><ul><li>Input: {{c1::undirected, connected \\(G = (V, E), edge\\ weights\\ w_e\\)}}</li><li>Goal: {{c2::Find the minimal size, connected subgraph of minimum weight, or the minimum spanning tree (MST)}}</li><li>Output: {{c3::The minimum weight spanning tree of&nbsp;\\(G\\) (MST)}}</li></ul>",
                        "The weight of a tree is the sum of the edge weights in the tree.<br><br>\\[w(T) = \\sum_{e \\ \\in \\ T}w(e)\\]"
                    ],
                    "guid": "AVPXl7neRt",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Tree</b></p><p>How do you calculate the <u>weight</u> of a <u>tree</u>?</p>",
                        "The <u>weight</u> of a <u>tree</u> is the sum of the edge weights in the tree.<br><br>\\[w(T) = \\sum_{e \\ \\in \\ T}w(e)\\]"
                    ],
                    "guid": "AEmBV-L-Tt",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Tree</b></p><p>A {{c2::<u>tree</u>}} is a {{c1::connected, acyclic graph}}.</p>",
                        "<i>Lecture GR3.3: Tree Properties</i>"
                    ],
                    "guid": "LnySNd?+gF",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Tree</b></p><p>A tree on {{c2::\\(n\\)}}&nbsp;vertices has exactly&nbsp;{{c1::\\(n-1\\)}} edges.</p>",
                        "<i>Lecture GR3.3: Tree Properties</i>"
                    ],
                    "guid": "IP3_LPB(q}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>In a tree, how many paths exist between every pair of vertices?<br></p>",
                        "1<br><br><i>Lecture GR3.3: Tree Properties</i>"
                    ],
                    "guid": "r3y~2CQ3c|",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>A connected graph&nbsp;\\(G=(V, E)\\) with |E| = {{c2::\\(|V| - 1\\)}} is a {{c1::tree}}.</p>",
                        "<i>Lecture GR3.3: Tree Properties</i>"
                    ],
                    "guid": "qcEF5Q_AeM",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>What are the <u>basic properties of a tree</u>?</p>",
                        "<ol><li>A tree on \\(n\\) vertices has exactly \\(n-1\\) edges.</li><li>In a tree, exactly one path exists between every pair of vertices.</li><li>Any connected \\(G=(V,E)\\) with \\(|E| = |V| - 1\\) is a tree.</li></ol><i><br>Lecture GR3.3: Tree Properties</i>"
                    ],
                    "guid": "t?X.2LoQLk",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>In terms of the MST problem:</p><p>A {{c1::cut}}&nbsp;of an undirected graph \\(G=(V,E)\\) is {{c2::a set of edges which partition the vertices into 2 sets, \\(S\\) and \\(\\overline{S}\\) \\((V=S \\cup \\overline{S})\\)}}.</p>",
                        "\\(cut(S, \\overline{S}) = \\left\\{ (v,w) \\in E: v \\in S, w \\in \\overline{S} \\right\\} = \\) the edges crossing between \\(S \\leftrightarrow \\overline{S}\\).<br>\\(\\overline{S}\\) is the complement of \\(S\\) (and vice-versa)<br><br><br><i>Lecture GR3.8: Cuts</i>"
                    ],
                    "guid": "ly{02jnip]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Graphs\n</h1>\n<h2>\n  MST Key Ideas\n</h2>\n<p>\n  Starting with MST T:\n</p>\n<ul>\n  <li>{{c1::Adding an edge to T creates a cycle. Removing any edge from that cycle creates a new MST T'. \\(T'=T \\cup c^* - e', w_{c^*} \\leq w_{e'}\\)::Cycle property}}</li>\n  <li>{{c2::A minimum weight edge across a cut is part of an MST.::Cut property}}</li>\n</ul>",
                        ""
                    ],
                    "guid": "K9X,K)-_S5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>Graph \\(G=(V,E)\\)</p><p>MST \\(T=(V,E')\\)</p><p>\\(e \\notin E'\\) and \\(weight(e)\\) is <u>decreased</u></p>",
                        "If the edge is not in the MST, and decreased, you add the edge to the MST, run DFS to find the cycle based on the \\(prev[ \\ ]\\) array starting at vertex \\(w\\) of the (\\(w \\to v\\)) <u>back edge</u>, and then remove the heaviest edge of the edges you find in the \\(prev[ \\ ]\\) array.<br><br>Running Time: \\(O(n+m)\\)"
                    ],
                    "guid": "F%*l{T=[GI",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>The cycle property of an MST states that \"{{c1::for any cycle \\(C\\) in the graph, if the weight of an edge \\(e\\) of \\(C\\) is larger than the individual weights of all other edges in \\(C\\), then this edge cannot belong to an MST}}\".</p>",
                        ""
                    ],
                    "guid": "kw$|lePDay",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><div>Graph \\(G=(V,E)\\)</div><div>MST \\(T=(V,E')\\)<br><br></div><div>\\(e \\in E'\\) and \\(weight(e)\\) is&nbsp;<u>increased</u></div>",
                        "<ul><li>remove \\(edge \\ e=(u,w)\\) from \\(MST \\to MST'\\)</li><li>run \\(explore(u, MST')\\) to find vertices reachable from \\(u \\to T_1\\) = {vertices reachable from \\(u\\)}</li><li>run \\(explore(w, MST')\\) to find vertices reachable from \\(w \\to T_2\\) = {vertices reachable from \\(w\\)}</li><li>iterate over edges \\(e=(x,y)\\) in \\(G\\) (for \\(e=(x,y) \\in G\\): if \\(x \\in T_1\\) and \\(y \\in T_2\\) (or vice-versa), cut_edges.add\\(((x,y)) \\to\\)&nbsp;cut_edges = {cut edges between \\(T_1\\) \\(\\leftrightarrow\\) \\(T_2\\)}</li><li>find the lightest cut edge (for \\(e=(a,b) \\in \\)&nbsp;cut_edges:&nbsp;&nbsp;\\(\\text{lightest_edge}= min(\\text{lightest_edge}, w(a,b)) \\to \\)&nbsp;lightest_edge</li><li>add the lightest cut edge to the MST'.add(lightest_edge) \\(\\to\\) MST</li></ul><br>Running Time: \\(O(n+m)\\)"
                    ],
                    "guid": "wW8_Dlj[H3",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>Prim's algorithm works correctly when there are negative edges.</p><p><i>True or False&nbsp;</i></p>",
                        "<i><b>True</b></i>"
                    ],
                    "guid": "E-[j.67Dv?",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p><b>Minimum Spanning Trees</b></p><p>The lightest of the cut edges of a partial MST is the next edge that will be added to the MST.</p><p><i>True or False&nbsp;</i><br></p>",
                        "<i><b>True<br></b></i><b><br></b><i>Lecture GR3.9: Cut Property</i>"
                    ],
                    "guid": "G9o-DJ/OLN",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Kruskal's Algorithm Steps</h2><p>What are the steps of Kruskal's algorithm?</p>",
                        "<h3>\n  Kruskal's Algorithm\n</h3><ol><li>Sort the edges of the input graph&nbsp;\\(G\\)&nbsp;by increasing edge weight to get&nbsp;\\(E'\\)</li><li>Set&nbsp;\\(X = \\left\\{ \\ \\right\\}\\)</li><li>For each edge&nbsp;\\(e \\in E'\\): if adding edge&nbsp;\\(e\\)&nbsp;to&nbsp;\\(X\\)&nbsp;does not create a cycle, add edge&nbsp;\\(e\\)</li><li>Return&nbsp;\\(X\\)</li></ol>\n<h3>\n  Notes\n</h3>Running Time:&nbsp;\\(O(m \\ log \\ m)\\)<br><ol><li>\\(O(m \\ log \\ n)\\)&nbsp;via mergesort</li><li>Empty Union-Find datastructure</li><li>\\(O(m \\ log \\ n)=\\)&nbsp;\\(O(log \\ n)\\)&nbsp;to check for cycle using union-find data structure that is done&nbsp;\\(m\\)&nbsp;times</li><li>\\(X\\)&nbsp;is the MST</li></ol><br>Note: \\(O(m \\ log \\ m) = O(m \\ log \\ n)\\) in this algorithm because in an undirected graph there are \\(n\\) vertices and \\(n-1\\) edges (\\(m\\))<br><br><i>Lecture GR3.5-6: Kruskal's Algorithm and Krushkal's Analysis</i><br>"
                    ],
                    "guid": "H:I,fu;s$<",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>You are given a connected, undirected, weighted graph&nbsp;\\(G=(V, E)\\) such that all weights are distinct real numbers.<br></p><p>T/F? &nbsp;\\(G\\) has a unique MST.</p>",
                        "True"
                    ],
                    "guid": "AyaX5;18._",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>You are given a connected, undirected, weighted graph&nbsp;\\(G=(V, E)\\) such that all weights are distinct real numbers.</p><p>\\(G\\)&nbsp;can have no MST. T/F?<br></p>",
                        "False<br>It must have at least one MST because it is connected. It can have only one because the weights are distinct."
                    ],
                    "guid": "E3N[zfep(m",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>You are given a connected, undirected, weighted graph&nbsp;\\(G=(V, E)\\) such that all weights are distinct real numbers. T/F?</p><p>\\(G\\)&nbsp;can have multiple MSTs.<br></p>",
                        "False<br>\"all weights are distinct\" is key here. Thus there can be only 1&nbsp;<i>minimum</i>&nbsp;spanning tree."
                    ],
                    "guid": "o45Bn0Xc5B",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><p>You are given a connected, undirected, weighted graph&nbsp;\\(G=(V, E)\\) such that all weights are distinct real numbers.</p><p>T/F: Not enough information is given about&nbsp;\\(G\\)&nbsp;to make a conclusion about the number of MST.<br></p>",
                        "False<br>There can be only 1 MST. There could be multiple spanning trees, but only 1 minimum because the weights are distinct."
                    ],
                    "guid": "i@O7<S}V)%",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "graphs",
                        "mst"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f60e986-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "lpFeasibleRegion.svg",
                "paste-e3d26fc62cdf42a156899b05b55432960637a65f.jpg"
            ],
            "name": "LP1: Linear Programming",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Linear Programming\n</h1>\n<h2>\n  Max-flow via LP</h2><ul><li>Input: {{c1::directed \\(G=(V,E)\\) with capacities \\(c_e {\\gt} 0 \\&nbsp; \\forall \\ e \\in E\\)}}</li><li>LP: {{c2::\\(m\\) variables: \\(f_e\\) for every \\(e \\in E\\)::define variables}}</li><ul><li>Objective function:</li><ul><li>{{c3::\\[\\max \\sum_{\\overrightarrow{sv} \\in E} f_{sv}\\]}}</li></ul><li>Subject to:</li><ul><li>{{c4::Capacity constraint: for every \\(e \\in E, 0 \\leq f_e \\leq c_e\\)}}</li><li>{{c4::Conservation constraint: for every \\(v \\in V - \\{s, t\\}\\)&nbsp;\\[\\sum_{\\overrightarrow{wv} \\in E} f_{wv} = \\sum_{\\overrightarrow{vz} \\in E} f_{vz}\\]}}</li></ul></ul></ul>",
                        "<i>Source: Lecture LP1, Section 3</i>"
                    ],
                    "guid": "hAa{gyp4;d",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Simple 2D example</h2><p>\n  Basic production:</p><ul><li>Company makes A &amp; B</li><li>How many of each to maximize profit?</li><li>Each unit of:</li><ul><li>A makes $1 profit</li><li>B makes $6 profit</li></ul><li>Demand: \\(\\leq\\) 300 units of A and \\(\\leq\\) 200 of B</li><li>Supply: \\(\\leq\\) 700 hours, A takes 1 hour and B takes 3 hours</li></ul><br>Express the above as a LP problem:<br><br><ul><li>Variables:</li><ul><li>{{c1::Let \\(x_1\\) = # of units of A to produce/day}}</li><li>{{c1::Let \\(x_2\\) = # of units of B to produce/day}}</li></ul><li>Goal: {{c2::maximize \\(x_1 + 6x_2\\)}}</li><li>Constraints:</li><ul><li>{{c3::Demand: \\(0 \\leq x_1 \\leq 300, 0 \\leq x_2 \\leq 200\\)}}</li><li>{{c3::Supply: \\(x_1 + 3x_2 \\leq 700\\)}}</li></ul></ul>",
                        "<i>Source: Lecture LP1, Section 4</i>"
                    ],
                    "guid": "A2uWata[O2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Simple 2D example</h2><p>Given the following constraints, what will the feasible region look like?</p><ul><li>Objective: \\(\\max x_1 + 6x_2\\)</li><li>Subject to:</li><ul><li>\\(x_1 \\leq 300\\)</li><li>\\(x_2 \\leq 200\\)</li><li>\\(x_1 \\geq 0\\)</li><li>\\(x_2 \\geq 0\\)</li><li>\\(x_1 + 3x_2 \\leq 700\\)</li></ul></ul><p></p>",
                        "Each of the constraints is a half plane. The feasible region is the intersection of all of the constraints.<br><img src=\"lpFeasibleRegion.svg\"><br><i>Source: Lecture LP1, Section 6</i>"
                    ],
                    "guid": "lJmu@Sk[jJ",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Key Issues</h2><ul><li>Optimum may be {{c1::non-integer}}</li><li>LP \\(\\in\\) {{c2::P}}</li><li>ILP is {{c3::NP-Complete}}</li><li>The optimal point {{c4::lies on a vertex}}</li><li>Feasible region is {{c5::convex}}</li><li>If {{c6::a vertex is better than all its neighbors}} then {{c7::it is a global optimum}}</li></ul>",
                        "ILP = Integer Linear Programming<br>Other points may be as optimal as the vertex, but not better.<br><br><i>Source: Lecture LP1, Section 9</i>"
                    ],
                    "guid": "iZ3?}wq]`+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>3D Example</h2><p>Products A, B, &amp; C:</p><ul><li>Profit: $1 for A, $6 for B, $10 for C</li><li>Demand: \\(\\leq\\) 300 for A, \\(\\leq\\) 200 for B</li><li>Supply: \\(\\leq\\) 1000 total, A takes 1, B takes 3, C takes 2</li><li>Packaging: \\(\\leq\\) 500 total, B takes 1, C takes 3</li></ul><p>Reformulate as an LP problem:</p><ul><li>Variables: {{c1::\\(x_1, x_2, x_3\\) for quantities produced of A, B, C}}</li><li>Objective: {{c2::\\(\\max x_1 + 6x_2 + 10x_3\\)}}</li><li>Demand: {{c3::\\(x_1 \\leq 300, x_2 \\leq 200\\)}}</li><li>Supply: {{c3::\\(x_1 + 3x_2 + 2x_3 \\leq 1000\\)}}</li><li>Packaging: {{c3::\\(x_2 + 3x_3 \\leq 500\\)}}</li><li>Non-negativity: {{c4::\\(x_1, x_2, x_3 \\geq 0\\)}}</li></ul><p></p>",
                        "Missing constraints (e.g. \\(x_3\\) does not appear in the demand constraint) means it is unconstrained; there is no limit.<br><br><i>Source: Lecture LP1, Section 11</i>"
                    ],
                    "guid": "tkw)|xp4h",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>3D Example</h2><p>What will the geometric view of the formulation look like?</p><ul><li>Objective: \\(\\max x_1 + 6x_2 + 10x_3\\)<br></li><li>Subject to:</li><ul><li>\\(x_1 \\leq 300\\)</li><li>\\(x_2 \\leq 200\\)</li><li>\\(x_1 + 3x_2 + 2x_3 \\leq 1000\\)</li><li>\\(x_2 + 3x_3 \\leq 500\\)</li><li>\\(x_1, x_2, x_3 \\geq 0\\)</li></ul></ul>",
                        "<img src=\"paste-e3d26fc62cdf42a156899b05b55432960637a65f.jpg\"><br><br><i>Source: Lecture LP1, Section 12</i>"
                    ],
                    "guid": "r&zmBS]8dz",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Standard form</h2><p>What is the standard form for a LP problem?</p><ul><li>{{c1::\\(n\\) variables: \\(x_1, x_2, \\ldots, x_n\\)}}</li><li>{{c2::Objective function: \\(\\max c_1x_1 + c_2x_2 + \\ldots + c_nx_n\\)}}</li><li>{{c3::Subject to:}}</li><ul><li>{{c3::\\(\\begin{array}{rcl}\na_{11}x_1 + a_{12}x_2 + \\ldots + a_{1n}x_n &amp; \\leq &amp; b_1 \\\\\n&amp; \\vdots &amp; \\\\\na_{m1}x_1 + a_{m2}x_2 + \\ldots + a_{mn}x_n &amp; \\leq &amp; b_m\n\\end{array}\\)}}<br></li><li>{{c3::\\(x_1, \\ldots , x_n \\geq 0\\)}}</li></ul></ul>",
                        "<i>Source: Lecture LP1, Section 13</i>"
                    ],
                    "guid": "wMprz=ywnp",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Linear Algebra View</h2><p>How is a LP problem specified as a linear algebra problem?</p><ul><li>{{c1::variables:&nbsp;\\(x = \\left( \\substack{x_1\\\\ \\vdots \\\\x_n} \\right)\\)}}</li><li>{{c2::objective: \\(c = \\left( \\substack{c_1\\\\ \\vdots \\\\c_n} \\right)\\)}}</li><li>{{c3::constraint matrix: \\(\\underset{m \\times n}{A}\\)}}</li><li>{{c4::constraints \\(b = \\left( \\substack{b_1\\\\ \\vdots \\\\b_m} \\right)\\)}}</li><li>{{c5::objective function:&nbsp;\\(\\max c^T x\\)}}</li><li>{{c6::s.t. \\[\\begin{array}{rcl}\nAx &amp; \\leq &amp; b \\\\\nx &amp; \\geq &amp; 0\n\\end{array}\\]}}<br></li></ul>",
                        "<i>Source: Lecture LP1, Section 14</i>"
                    ],
                    "guid": "f0c?7<Y{<K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Converting</h2><p>Convert to standard form:</p><p></p><ul><li>\\(\\min c^T x&nbsp;\\Leftrightarrow\\) {{c1::\\(\\max -c^T x\\)}}</li><li>\\(a_1x_1 + \\ldots + a_nx_n \\geq b \\Leftrightarrow\\) {{c2::\\(-a_1x_1 - \\ldots - a_nx_n \\leq -b\\)}}</li><li>\\(a_1x_1 + \\ldots + a_nx_n = b \\Leftrightarrow\\) {{c3::\\(a_1x_1 + \\ldots + a_nx_n \\leq b \\text{ and } a_1x_1 + \\ldots + a_nx_n \\geq b\\)}}<br></li><li>\\(x &lt; 100 \\Leftrightarrow\\) {{c4::strict inequalities are ill-defined and not allowed}}</li><li>unconstrained \\(x \\Leftrightarrow\\) {{c5::create \\(x^+, x^-;\\ x^+ \\geq 0, x^- \\geq 0;\\ \\)replace \\(x\\) with \\(x^+ - x^-\\)}}</li></ul><p></p>",
                        "<i>Source: Lecture LP1, Section 15</i>"
                    ],
                    "guid": "xn`Mky6~3F",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Linear Algebra View</h2><p>Express the following in linear algebra form:</p><ul><li>Objective function: minimize \\(3x_1 - 2.5x_2 + x_3\\)</li><li>Constraints:</li><ul><li>\\[\\begin{array}{rcl}\nx_2 + x_3 &amp; \\geq &amp; 300 \\\\\n0.5x_1 + 7x_2 - 2x_3 &amp; = &amp; 4 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]<br></li></ul></ul><br><ul><li>objective function: \\(c = \\left( \\substack{{{c1::-3}}\\\\ {{c1::2.5}} \\\\ {{c1::-1}}} \\right)\\)<br></li><li>constraint matrix: \\[\\begin{bmatrix}\n&nbsp;{{c2::0}} &amp; {{c2::-1}} &amp; {{c2::-1}} \\\\\n&nbsp;{{c2::0.5}} &amp; {{c2::7}} &amp; {{c2::-2}} \\\\\n&nbsp;{{c2::-0.5}} &amp; {{c2::-7}} &amp; {{c2::2}}\n\\end{bmatrix}\\]</li><li>constraints \\(b = \\left( \\substack{\\ {{c3::-300}} \\\\ \\ {{c3::4}} \\\\ \\ {{c3::-4}} } \\right)\\)</li><li>\\(\\max c^T x\\)</li><li>s.t. \\[\\begin{array}{rcl}\nAx &amp; \\leq &amp; b \\\\\nx &amp; \\geq &amp; 0\n\\end{array}\\]<br></li></ul>",
                        "<i>Source: Lecture LP1, Section 15</i>"
                    ],
                    "guid": "kD4#*R!{]=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Geometric View</h2><ul><li>\\(n\\) variables \\(\\rightarrow\\) {{c1::\\(n\\) dimensions}}</li><li>|constraints| = {{c2::\\(n + m\\)}}</li><li>feasible region = {{c3::intersection of \\(n + m\\) halfspaces}}</li><li>vertices = points satisfying</li><ul><li>{{c4::\\(n\\)}}&nbsp;constraints with {{c5::equality}}</li><li>{{c4::\\(m\\)}}&nbsp;constraints with {{c5::inequaltiy}}</li><li>|vertices| {{c6::\\(\\leq {{n + m} \\choose n}\\)}}</li><li>|neighbors| {{c7::\\(\\leq nm\\)}}</li></ul></ul>",
                        "<i>m</i>&nbsp;are the given constraints. <i>n</i>&nbsp;are the non-negativity constraints.<br><br><i>Source: Lecture LP1, Section 17</i>"
                    ],
                    "guid": "G$>p(77ihR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "leech",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>LP algorithms</h2><ul><li>Polynomial-time algorithims<br></li><ul><li>{{c1::Ellipsoid algorithm}}</li><li>{{c1::Interior Point methods}}</li></ul><li>Simplex algorithm</li><ul><li>Complexity: {{c2::worst case exponential}}</li></ul></ul>",
                        "<i>Source: Lecture LP1, Section 18</i>"
                    ],
                    "guid": "hK,Ma|PgK+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Simplex Algorithm</h2><ul><li>{{c1::Start at \\(x=0\\)}}</li><li>{{c1::Look for neighboring vertices with higher objective value, move there and repeat}}</li><li>{{c1::If there are no neighbors are smaller, then the whole feasible region is smaller. Output current point.}}</li></ul>",
                        "\\(x=0\\) satisfies the <i>n</i>&nbsp;non-negativity constraints. If it does not satisfy any of the <i>m</i>&nbsp;constraints then it is not in the feasible region and the feasible region is empty.<br><br><i>Source: Lecture LP1, Section 18</i>"
                    ],
                    "guid": "e6PZM|0,KD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><div><b>Converting to Standard Form</b><br><br>What should we do if we want to <u>minimize</u>&nbsp;the objective function?<br><br>\\(\\min c^Tx \\)</div>",
                        "Multiply by&nbsp;\\(-1\\) and take the \\(\\max\\).<br><br>\\(\\min c^Tx \\Leftrightarrow&nbsp;\\max -c^Tx\\)<br><br>\\(\\min 3x_1 - 2.5x_2 + x_3 \\Leftrightarrow\\) \\(\\max -3x_1 + 2.5x_2 - x_3\\)<br><br>Multiply by&nbsp;\\(-1\\) and take the \\(\\max\\).<br><br><i>Lecture LP1.15: Converting to Standard Form</i>"
                    ],
                    "guid": "J6=*3ER7ti",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><div><b>Converting to Standard Form</b><br><br>What should we do if we have constraints that are <u>at least b</u>&nbsp;(\\(\\ge b)\\)?<br><br>\\(Ax \\ge b? \\)&nbsp;</div>",
                        "Multiply by&nbsp;\\(-1\\) and flip the inequality to&nbsp;\\(\\le\\).<br><br>\\(a_1x_1 + \\ldots + a_nx_n \\geq b \\Leftrightarrow -a_1x_1 - \\ldots - a_nx_n \\leq -b\\)<br><br>\\(x_2 + x_3 \\geq 300&nbsp; \\Leftrightarrow -x_2 - x_3&nbsp; \\leq&nbsp; -300 \\)<br><br><i>Lecture LP1.15: Converting to Standard Form</i>"
                    ],
                    "guid": "Lf+is^|.I=",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><div><b>Converting to Standard Form</b><br><br>What should we do if we have constraints that are <u>equal to b</u>&nbsp;(\\( Ax = b)\\)?<br><br>\\(a_1x_1 + \\ldots + a_nx_n = b \\Leftrightarrow ?\\)</div>",
                        "Replace with 2 inequality constraints.<br><ol><li>Create&nbsp;\\(\\leq\\) inequality constraint.</li><ul><li>\\(a_1x_1 + \\ldots + a_nx_n \\leq b\\)</li></ul><li>Create&nbsp;\\(\\geq\\) inequality constraint and convert it to standard form (multiply both sides by \\(-1\\)).</li><ul><li>\\(a_1x_1 + \\ldots + a_nx_n \\geq b \\Rightarrow -a_1x_1 - \\ldots - a_nx_n \\leq -b\\)</li></ul></ol>\\(0.5x_1 + 7x_2 - 2x_3 = 4 \\Leftrightarrow 0.5x_1 + 7x_2 - 2x_3 \\leq 4, -0.5x_1 - 7x_2 + 2x_3 \\leq -4\\)<br><i><br><br><br>Lecture LP1.15: Converting to Standard Form</i><br>"
                    ],
                    "guid": "I$Xi,$^.gx",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><div><b>Converting to Standard Form</b><br><br>What should we do if we have constraints with a <u>strict inequality</u>?&nbsp;(e.g., \\(x \\lt 100\\), \\(x \\gt 50\\))?<br></div>",
                        "Strict inequalities are <u>not allowed</u> in linear programming.<br><br>\\(\\nless \\&nbsp; \\ngtr\\)<br><br><i>Lecture LP1.15: Converting to Standard Form</i>"
                    ],
                    "guid": "G.=8#xP/u6",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><div><b>Converting to Standard Form</b><br><br>What should we do if we have an <u>unconstrained variable</u>? (\\(e.g., x)\\)<br></div>",
                        "<ol><li>Create 2 new variables,&nbsp;\\(x^+ \\text{ and } x^-\\).</li><li>Add non-negative constraints&nbsp;\\((x^+ \\geq 0, x^- \\geq 0)\\).</li><li>Replace variable&nbsp;\\(x\\) with&nbsp;\\(x = x^+ - x^-\\).</li></ol><br><i>Lecture LP1.15: Converting to Standard Form</i><br>"
                    ],
                    "guid": "F@b)Tn}L6[",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Linear Programming (LP) is in the {{c1::P}} complexity class.",
                        "<i>LP&nbsp;</i>\\(\\in\\) P<i><br><br>Lecture LP1.9: Key Issues</i>"
                    ],
                    "guid": "u6{IcHmfy4",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Integer Linear Programming (ILP) is in the {{c1::NP-complete}} complexity class.",
                        "<i>ILP&nbsp;</i>\\(\\in\\) NP-complete<i><br></i><i>LP&nbsp;</i>\\(\\in\\) P<br><i><br></i><i>Lecture LP1.9: Key Issues</i>"
                    ],
                    "guid": "P+M?(Mf(lL",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>The optimal point for a linear program lies at a {{c1::vertex}} of the feasible region.",
                        "<i>Lecture LP1.9: Key Issues</i>"
                    ],
                    "guid": "c<_p(C7Qbu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Given the following linear program in standard form:<br><br>Objective function: \\(\\max x_1 + 6x_2 + 10x_3\\)<br><br>\\[\\begin{array}{rcl}\nx_1 &amp; \\leq &amp; 300 \\\\\nx_2 &amp; \\leq &amp; 200 \\\\\nx_1 + 3x_2 + 2x_3 &amp; \\leq &amp; 1000 \\\\\nx_2 + 3x_3 &amp; \\leq &amp; 500 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]<br><br>What does objective function \\(c\\) equal?",
                        "\\(c = \\left( \\substack{1\\\\ 6 \\\\ 10} \\right)\\)<br><br>\\(b = \\left( \\substack{300 \\\\ 200 \\\\ 1000 \\\\ 500} \\right)\\)<br>\\[A =&nbsp;\\begin{bmatrix}\n1 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 \\\\\n1 &amp; 3 &amp; 2 \\\\\n0 &amp; 1 &amp; 3\n\\end{bmatrix}\\]"
                    ],
                    "guid": "oyM@laz[%*",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Given the following linear program in standard form:<br><br>Objective function: \\(\\max x_1 + 6x_2 + 10x_3\\)<br><br>\\[\\begin{array}{rcl}\nx_1 &amp; \\leq &amp; 300 \\\\\nx_2 &amp; \\leq &amp; 200 \\\\\nx_1 + 3x_2 + 2x_3 &amp; \\leq &amp; 1000 \\\\\nx_2 + 3x_3 &amp; \\leq &amp; 500 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]<br>What does constraint matrix \\(A\\) equal?",
                        "\\[A =&nbsp;\\begin{bmatrix}\n1 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 \\\\\n1 &amp; 3 &amp; 2 \\\\\n0 &amp; 1 &amp; 3\n\\end{bmatrix}\\]<br>\\(b = \\left( \\substack{300 \\\\ 200 \\\\ 1000 \\\\ 500} \\right)\\)<br><br>\\(c = \\left( \\substack{1\\\\ 6 \\\\ 10} \\right)\\)"
                    ],
                    "guid": "Jkphi^Hd}k",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming",
                        "LP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Given the following linear program in standard form:<br><br>Objective function: \\(\\max x_1 + 6x_2 + 10x_3\\)<br><br>\\[\\begin{array}{rcl}\nx_1 &amp; \\leq &amp; 300 \\\\\nx_2 &amp; \\leq &amp; 200 \\\\\nx_1 + 3x_2 + 2x_3 &amp; \\leq &amp; 1000 \\\\\nx_2 + 3x_3 &amp; \\leq &amp; 500 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]<br><br>What does constraints \\(b\\) equal?",
                        "\\(b = \\left( \\substack{300 \\\\ 200 \\\\ 1000 \\\\ 500} \\right)\\)<br><br>\\[A =&nbsp;\\begin{bmatrix}\n1 &amp; 0 &amp; 0 \\\\\n0 &amp; 1 &amp; 0 \\\\\n1 &amp; 3 &amp; 2 \\\\\n0 &amp; 1 &amp; 3\n\\end{bmatrix}\\]<br>\\(c = \\left( \\substack{1\\\\ 6 \\\\ 10} \\right)\\)"
                    ],
                    "guid": "lz}s1amfL}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Convert the following linear program to standard form:<br><br>Objective function: \\(\\min 3x_1 - 2.5x_2 + x_3\\)<br>\\[\\begin{array}{rcl}\nx_2 + x_3 &amp; \\geq &amp; 300 \\\\\n0.5x_1 + 7x_2 - 2x_3 &amp; = &amp; 4 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]<br>",
                        "Objective function: \\(\\max -3x_1 + 2.5x_2 - x_3\\)<br>\\[\\begin{array}{rcl}\n-x_2 - x_3 &amp; \\leq &amp; -300 \\\\\n0.5x_1 + 7x_2 - 2x_3 &amp; \\leq &amp; 4 \\\\\n-0.5x_1 - 7x_2 + 2x_3 &amp; \\leq &amp; -4 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]"
                    ],
                    "guid": "Qc*#(soF[n",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1>Convert the following linear program to standard form:<br><br>Objective function: \\(\\min 3x_1 - 2.5x_2 + x_3 \\Leftrightarrow\\)&nbsp;{{c1::\\(\\max -3x_1 + 2.5x_2 - x_3\\)}}<br><br>\\[\\begin{array}{rcl}\nx_2 + x_3 \\geq 300 &amp; \\Leftrightarrow &amp; {{c2::-x_2 - x_3 \\leq -300}} \\\\\n0.5x_1 + 7x_2 - 2x_3 = 4 &amp; \\Leftrightarrow &amp; {{c3::0.5x_1 + 7x_2 - 2x_3 \\leq  4 \\text{ and } -0.5x_1 - 7x_2 + 2x_3 \\leq -4}} \\\\\nx_1,x_2,x_3 \\geq 0\n\\end{array}\\]<br><br>",
                        "Objective function: \\(\\max -3x_1 + 2.5x_2 - x_3\\)<br><br>\\[\\begin{array}{rcl}\n-x_2 - x_3 &amp; \\leq &amp; -300 \\\\\n0.5x_1 + 7x_2 - 2x_3 &amp; \\leq &amp; 4 \\\\\n-0.5x_1 - 7x_2 + 2x_3 &amp; \\leq &amp; -4 \\\\\nx_1,x_2,x_3 &amp; \\geq &amp; 0\n\\end{array}\\]"
                    ],
                    "guid": "NedTI%=W:T",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "exercise",
                        "linear_programming",
                        "LP1"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f62d3c2-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "lpOptimalUnbounded.svg",
                "paste-04dcadc2db44706ce6d6719aa4cbe18a99fb9a01.jpg",
                "paste-96dc919c6488aca2abe574369af3555d40e22043.jpg"
            ],
            "name": "LP2: Geometry",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><p><b>Linear Program in Standard Form</b></p><ul><li>objective function: {{c1::\\(max \\ c^Tx\\)}}</li><li>s.t. (constraints):&nbsp;{{c2::\\(Ax \\le b, x \\ge 0\\)}}</li><li>{{c3::\\(n\\)}} {{c4::variables}}</li><li>{{c3::\\(m\\)}} {{c4::constraints}}</li></ul>",
                        "<i>LP2.1: LP Geometry<br></i>"
                    ],
                    "guid": "FY3Ooe5Z}X",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "geometry",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><p>Optimum of LP is achieved at the vertex of the feasible region, <b>except</b>&nbsp;if the LP is:</p><ol><li>{{c1::<u><b>infeasible</b></u>: The LP is infeasible, meaning the feasible region is empty - there are no points which satisfy all the constaints.}}<br></li><li>{{c2::<u><b>unbounded</b></u>: The LP is unbounded, meaning the optimal is arbitrarily large - the maximum objective function increases indefinitely.}}</li></ol>",
                        "<ul><li>infeasibility is dependent only on the constraints</li><li>unboundedness if dependent only on the objective function</li></ul>\n<h2>\n  Infeasible Example\n</h2><ul><li>\\(\\max 5x -7y\\)</li><li>s.t.</li><ul><li>\\(x+y \\leq 1\\)<br></li><li>\\(3x + 2y \\geq 6\\)<br></li><li>\\(x, y \\geq 0\\)<br></li></ul></ul><img src=\"paste-04dcadc2db44706ce6d6719aa4cbe18a99fb9a01.jpg\"><br>\nFeasible region is empty\n<h2>LP Unbounded</h2>\n<ul><li>\\(\\max x+y\\)<br></li><li>s.t.</li><ul><li>\\(x-y \\leq 1\\)<br></li><li>\\(x+5y \\geq 3\\)<br></li><li>\\(x, y \\geq 0\\)</li></ul></ul><img src=\"paste-96dc919c6488aca2abe574369af3555d40e22043.jpg\"><br><i>LP1.2-4</i><br>"
                    ],
                    "guid": "J_=qqy}0p^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "geometry",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><p>An optimal value may exist in an unbounded linear program (i.e., unbounded feasible region).</p><p><i>True or False</i></p>",
                        "<i><b>True</b></i><u style=\"\"><b><br></b></u><b><u><br></u></b>See the example below where the optimal value is at vertex&nbsp;\\((0,0)\\).<br><ul><li>\\(\\max 2x-3y\\)<br></li><li>s.t.&nbsp;</li><ul><li>\\(\\begin{array}{rcl}\nx-y &amp; \\le  &amp; 1\\\\\nx + 5y &amp; \\ge &amp; 3\\\\\nx, y &amp; \\ge &amp; 0\n\\end{array}\\)<br></li></ul></ul><img src=\"lpOptimalUnbounded.svg\"><br><br><br><i>LP2.5: Unbounded to Bounded</i><br>"
                    ],
                    "guid": "lXb>3jR5,,",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "geometry",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><p>Steps to determine if an LP is feasible:</p><ol><li>{{c1::Make a new <b>unrestricted </b>(can be any positive or negative value)&nbsp;variable&nbsp;\\(z\\).}}<br></li><li>{{c2::Modify our constraints formula to add the variable&nbsp;\\(z\\) to the left-hand side of the formula.</li><ul><li><b><u>from</u></b>:&nbsp;\\(a_1x_1+a_2x_2+...+a_nx_n \\le b\\)</li><li><b><u>to</u></b>: \\(a_1x_1+a_2x_2+...+a_nx_n + z \\le b\\) }}</li></ul><li>{{c3::Create&nbsp;a <i>new</i>&nbsp;LP:<br></li><ul><li><u><b>objective function</b></u>:&nbsp;\\(\\max z\\)</li><li><u><b>s.t.</b></u>&nbsp;\\(Ax + z \\le b, x \\ge 0\\) }}</li></ul><li>{{c4::\\(z \\ge 0\\) shows feasibility</li><ol><li>Also&nbsp;gives a starting point for the simplex algorithm on the original LP.}}</li></ol></ol>",
                        "<i>LP2.7: Infeasible?</i>"
                    ],
                    "guid": "s8c9etYun!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "geometry",
                        "linear_programming"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f647af6-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "LP3: Duality",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>What are the steps to convert a primal LP (in standard form) to its dual LP?<br><br>Example:<br><br>Objective function: \\(\\max x_1 + 6x_2 + 10x_3 \\)&nbsp;<br>\\[\\begin{array}{rcl}\nx_1 \\leq &amp; 300\\\\\nx_2 \\leq &amp; 200\\\\\nx_1 + 3x_2 + 2x_3 \\leq &amp; 1000\\\\\nx_2 + 3x_3 \\leq &amp; 500\\\\\nx_1,x_2,x_3 \\geq &amp; 0\n\\end{array}\\]<br><br>1. {{c1::Multiply both sides of each constraint (\\(\\text{constraint}_i\\)) by&nbsp;\\(y_i\\).}}<br><br>{{c1::\\[\\begin{array}{rcl}\nx_1y_1 \\leq &amp; 300y_1\\\\\nx_2y_2 \\leq &amp; 200y_2\\\\\nx_1y_3 + 3x_2y_3 + 2x_3y_3 \\leq &amp; 1000y_3\\\\\nx_2y_4 + 3x_3y_4 \\leq &amp; 500y_4\\\\\n\\end{array}\\]}}<br><br>2. {{c2::Create a new \"super\" equation by combining all of the left-hand and right-hand sides of the constraints.}}<br><br>{{c2::\\( x_1y_1 + x_2y_2 + x_1y_3 + 3x_2y_3 + 2x_3y_3 + x_2y_4 + 3x_3y_4 \\leq 300y_1 + 200y_2 + 1000y_3 + 500y_4\\)}}<br><br><br>3. {{c3::Combine like&nbsp;\\(x\\) terms.}}<br><br>{{c3::\\( x_1(y_1 + y_3) + x_2(y_2 + 3y_3 + y_4) + x_3(2y_3 + 3y_4) \\leq 300y_1 + 200y_2 + 1000y_3 + 500y_4\\)}}<br><br><br>4. {{c4::Take the left-hand side of the equation and match up the&nbsp;<i>x</i>&nbsp;terms with the objective function term, remove the <i>x</i>&nbsp;terms.}}<br><br>{{c4::primal LP objective function: \\(\\max 1x_1 + 6x_2 + 10x_3 \\)&nbsp;<br>\\[\\begin{array}{rcl}\nx_1(y_1 + y_3) \\geq 1x_1 &amp; \\Rightarrow &amp; y_1 + y_3 \\geq 1\\\\\nx_2(y_2 + 3y_3 + y_4) \\geq 6x_2 &amp; \\Rightarrow &amp; y_2 + 3y_3 + y_4\\geq 6\\\\\nx_3(2y_3 + 3y_4) \\geq 10x_3 &amp; \\Rightarrow &amp; 2y_3 + 3y_4 \\geq 10\\\\\n\\end{array}\\]<br>}}<br>5. {{c5::Set the objective function to&nbsp;<i>minimize</i>&nbsp;the right-hand side of the equation.}}<br><br>{{c5::dual LP objective function: \\(\\min 300y_1 + 200y_2 + 1000y_3 + 500y_4\\)}}",
                        ""
                    ],
                    "guid": "Lw})-KfvOg",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "exercise",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>What is the format of the dual LP?<br><br><b>Objective Function</b>:&nbsp;{{c1::\\( \\min b^Ty&nbsp; \\)}}<br><br><b>Subject to</b>:{{c2::<br>&nbsp; &nbsp; &nbsp; \\(A^Ty \\ge c \\)<br>&nbsp; &nbsp; \\(y \\ge 0\\)}}<br><br>{{c3::\\(m\\)}} variables<br>{{c3::\\(n\\)}} constraints<br>",
                        ""
                    ],
                    "guid": "I>Fm{)?:Ur",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>The weak duality theorem states that&nbsp;{{c1::\\(c^Tx \\leq b^Ty\\) given a feasible \\(x\\) for the primal LP and feasible \\(y\\) for dual LP}}.",
                        "Any feasible&nbsp;\\(x\\) for the Primal LP is upper bounded by any feasible&nbsp;\\(y\\) of the Dual LP."
                    ],
                    "guid": "pe-$tz*gEj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>The first corollary for the weak duality theorem states that:<br>If feasible \\(x\\) for primal LP = feasible \\(y\\) for dual LP, then:&nbsp;<br><ul><li>{{c1::\\(c^Tx = b^Ty\\)}}<br></li><li>{{c1::\\(x\\) is max of primal LP and&nbsp;\\(y\\) is min of dual LP.}}<br></li><li>{{c1::Max-Flow = Min-Cut}}</li></ul>",
                        ""
                    ],
                    "guid": "g`^Y#*qhx>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>The second corollary for the weak duality theorem states that if the primal LP is {{c1::unbounded}}, then the Dual LP is {{c2::infeasible}}.",
                        ""
                    ],
                    "guid": "k77?0UGt?`",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>The second corollary for the weak duality theorem states that if the dual LP is {{c1::unbounded}}, then the primal LP is {{c2::infeasible}}.",
                        ""
                    ],
                    "guid": "v3M7YDO(._",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>It is possible to have a primal LP and a dual LP that are both infeasible.<br><br><i>True or False</i>",
                        "<i><b>True</b></i>"
                    ],
                    "guid": "PuC~-:_qu|",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>How do you check if a <u>dual LP is feasible</u>?<br><ol><li>{{c1::Check if the primal LP is feasible (look for&nbsp;\\(z \\ge 0\\)). If the primal LP is infeasible, then the problem is not solvable.&nbsp;}}</li><li>{{c2::Check if the dual LP is feasible (look for&nbsp;\\(z \\ge 0\\)).<ul><li>If the dual LP is infeasible, then the primal LP is unbounded (has no optimal).</li><li>If the dual LP is feasible, then the primal LP is bounded (has an optimal).}}</li></ul></li></ol>",
                        ""
                    ],
                    "guid": "l@08eNUnpN",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>If the <u>primal and dual LP</u> of a problem are both <u>feasible</u>, what can you determine about the <u>boundedness</u> of the primal LP?<br>",
                        "If the primal and dual LP are both feasible, <u>the primal LP is bounded</u> (has an optimal)."
                    ],
                    "guid": "pGSkdg;mbF",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>If the <u>primal LP is feasible</u> and the <u>dual LP is infeasible</u>, what can you determine about the <u>boundedness</u> of the primal LP?<br>",
                        "If the primal LP is feasible and the dual is infeasible, <u>the primal LP is unbounded</u> (has no optimal).<br><br>Primal LP Feasible + Dual LP Infeasible = Primal LP Unbounded"
                    ],
                    "guid": "E4TH_U9q~T",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>The <u>strong duality theorem</u> states that {{c1::the primal LP is feasible and bounded iff the dual LP is feasible and bounded}}.<br>",
                        "<ul><li>primal LP is feasible and bounded&nbsp;\\( \\Leftrightarrow \\)&nbsp;dual LP is feasible and bounded</li><li>primal LP has an optimal point&nbsp;\\(x*\\)&nbsp;\\(\\Leftrightarrow\\)&nbsp;dual LP has an optimal point&nbsp;\\(y*\\)</li><li>\\(c^Tx^* = b^Ty^*\\)</li></ul><i><br>LP3.15: Strong Duality</i><br>"
                    ],
                    "guid": "Fb||Rbw(qq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><h2>Duality</h2>\n<table border=\"1\" cellpadding=\"10\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td colspan=\"2\">{{c2::Dual}}</td>\n</tr>\n<tr>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>{{c2::Feasible}}</td>\n<td>{{c2::Infeasible}}</td>\n</tr>\n<tr>\n<td rowspan=\"2\">{{c2::Primal}}</td>\n<td>{{c2::Feasible}}</td>\n<td>{{c1::Both are Bounded}}</td>\n<td>{{c1::Primal is Unbounded}}</td>\n</tr>\n<tr>\n<td>{{c2::Infeasible}}</td>\n<td>{{c1::Dual is Unbounded}}</td>\n<td>{{c1::N/A}}</td>\n</tr>\n</tbody>\n</table>",
                        ""
                    ],
                    "guid": "FT%{!*WWYy",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Linear Programming</h1><b>Duality</b><br><br>Convert the following primal LP to the dual LP:<br><br>Objective function: \\(\\max x_1 + 6x_2 + 10x_3 \\)&nbsp;<br><br>\\[\\begin{array}{rcl}\nx_1 \\leq &amp; 300&nbsp; \\\\\nx_2 \\leq &amp; 200&nbsp; \\\\\nx_1 + 3x_2 + 2x_3 \\leq &amp; 1000&nbsp; \\\\\nx_2 + 3x_3 \\leq &amp; 500&nbsp; \\\\\nx_1,x_2,x_3 \\geq &amp; 0\n\\end{array}\\]<u>Dual LP<br></u><br>Objective function:&nbsp;{{c1::\\(\\min 300y_1 + 200y_2 + 1000y_3 + 500y_4\\)}}<br>\\[\\begin{array}{rcl}\n{{c2::y_1 + y_3}} &amp; {{c3::\\geq}}&nbsp;&amp; {{c3::1}}&nbsp;\\\\\n{{c2::y_2 + 3y_3 + y_4}} &amp; {{c3::\\geq}} &amp; {{c3::6}}&nbsp;\\\\\n{{c2::2y_3 + 3y_4}}&nbsp;&amp; {{c3::\\geq}} &amp; {{c3::10}}&nbsp;\\\\\n{{c4::y_1,y_2,y_3,y_4}} &amp; {{c4::\\geq}} &amp; {{c4::0}}\n\\end{array}\n\\]<br>",
                        ""
                    ],
                    "guid": "O%|kKpK}xq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "duality",
                        "exam3",
                        "exercise",
                        "linear_programming"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Linear Programming\n</h1>\n<h2>\n  Duality</h2>\n<p>Given:</p><ul><li>\\(\\max c^T x\\)<br></li><li>subject to:</li><ul><li>\\(Ax \\leq b\\)<br></li><li>\\(x \\geq 0\\)<br></li></ul><li>The primal and dual LP are feasible.</li><li>\\(x^*\\)&nbsp;is a vector in the feasible region and&nbsp;\\(y^*\\)&nbsp;is a vector in the dual LP.</li></ul><p>T/F: \\(A^T y^* \\geq c\\)</p>",
                        "True. This is the standard form for the constraint for dual LP."
                    ],
                    "guid": "o6p@Q3-2}[",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP3"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Linear Programming\n</h1>\n<h2>\n  Duality</h2>\n<p>Given:</p><ul><li>\\(\\max c^T x\\)<br></li><li>subject to:</li><ul><li>\\(Ax \\leq b\\)<br></li><li>\\(x \\geq 0\\)<br></li></ul><li>The primal and dual LP are feasible.</li><li>\\(x^*\\)&nbsp;is a vector in the feasible region and&nbsp;\\(y^*\\)&nbsp;is a vector in the dual LP.</li></ul><p>T/F: The dual LP maximizes the linear function&nbsp;\\(f(y)-b^Ty\\).</p>",
                        "False. The objective function of the dual LP is&nbsp;\\(\\min b^T y\\)."
                    ],
                    "guid": "m4/Q@D9tE#",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP3"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Linear Programming\n</h1>\n<h2>\n  Duality</h2>\n<p>Given:</p><ul><li>\\(\\max c^T x\\)<br></li><li>subject to:</li><ul><li>\\(Ax \\leq b\\)<br></li><li>\\(x \\geq 0\\)<br></li></ul><li>The primal and dual LP are feasible.</li><li>\\(x^*\\)&nbsp;is a vector in the feasible region and&nbsp;\\(y^*\\)&nbsp;is a vector in the dual LP.</li></ul><p>T/F: The primal LP is bounded.</p>",
                        "True. If the dual is feasible, the primal must be bounded."
                    ],
                    "guid": "Jbx2dG<T!H",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP3"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Linear Programming\n</h1>\n<h2>\n  Duality</h2>\n<p>Given:</p><ul><li>\\(\\max c^T x\\)<br></li><li>subject to:</li><ul><li>\\(Ax \\leq b\\)<br></li><li>\\(x \\geq 0\\)<br></li></ul><li>The primal and dual LP are feasible.</li><li>\\(x^*\\)&nbsp;is a vector in the feasible region and&nbsp;\\(y^*\\)&nbsp;is a vector in the dual LP.</li></ul><p>T/F:&nbsp;\\(c^T x^* \\leq b^T y^*\\)</p>",
                        "True."
                    ],
                    "guid": "z9W~[}4.DL",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "linear_programming",
                        "LP3"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f6636ca-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "LP4: Max-SAT Approximation",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\nFor a formula f with m clauses:<br><ul><li>Let m* denote {{c1::the max # of satisfied clauses}}</li><li>\\(m^* \\leq\\){{c2::\\(m\\)}}<br></li><li>Construct an algorithm A on input f which outputs&nbsp;\\(l\\)&nbsp;where&nbsp;{{c3::\\(l \\geq \\frac{m^*}{2}\\)}}</li></ul>",
                        "\\(\\frac12\\)&nbsp;- approximate algorithm<br><em>Source: Lecture LP4, Section 2</em>"
                    ],
                    "guid": "E`--?I#]r6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Outline\n</h2>\n<p>\n  How close will the approximation get?\n</p>\n<ol><li>Simple alg:&nbsp;{{c1::\\(\\frac12\\)&nbsp;- approx algorithm}}</li><li>LP-based:&nbsp;{{c2::\\(\\left(1 - \\frac1e\\right)\\)&nbsp;- approx algorithm}}</li><li>Best of 2:&nbsp;{{c3::\\(\\frac34\\)&nbsp;- approx algorithm}}</li></ol>",
                        "<em>Source: Lecture LP4, Section 3</em>"
                    ],
                    "guid": "sB.j159vCT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Simple Scheme</h2>\n<p>\n  Consider input f with variables&nbsp;\\(x_1, \\ldots , x_n\\)&nbsp;and clauses&nbsp;\\(C_1, \\ldots , C_m\\).</p>\n<ol><li>Random assignment: Set&nbsp;\\(x_i ={{c1::\n\\left\\{\n\\begin{array}{}\nT \\text{ with prob } \\frac12\\\\\nF \\text{ with prob } \\frac12\\\\\n\n\\end{array}\n\\right.}}\\)</li><li>Let W = # of satisfied clauses<br>\\[E[W] ={{c2::\\sum_{l=0}^m l\\ Pr(W=l)}}\\]</li></ol>",
                        "E is expected value, l is number of satisfied clauses<br><em>Source: Lecture LP4, Section 4</em>"
                    ],
                    "guid": "eqAPKhdg#t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Expectation</h2>\n<p>W = # of satisfied clauses</p>\n<ol><li>For clause&nbsp;\\(C_j\\)<br>let&nbsp;\\(W_j ={{c1::\n\\left\\{\n\\begin{array}{l}\n1 \\text{ if } C_j \\text{ is satisfied}\\\\\n0 \\text{ if not}\\\\\n\\end{array}\n\\right.}}\\)</li><li>\\(W = {{c2::\\sum_{j=1}^m W_j}}\\)<br></li><li>\\(E[W] = {{c3:: E\\left[\\sum_{j=1}^m W_j \\right] = \\sum_{j=1}^m E\\left[ W_j \\right] }}\\)<br></li></ol>",
                        "<br><em>Source: Lecture LP4, Section 5</em>"
                    ],
                    "guid": "N]_TLPd,<e",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Analysis</h2>\nFor clause&nbsp;\\(C_j\\)&nbsp;let&nbsp;\\(W_j =\n\\left\\{\n\\begin{array}{l}\n1 \\text{ if } C_j \\text{ is satisfied}\\\\\n0 \\text{ if not}\\\\\n\\end{array}\n\\right.\\)<br>\\[\\begin{array}{rl}\nE[W_j] &amp;=&amp; {{c1::1 \\times Pr(W_j=1) + \\cancel{0 \\times Pr(W_j=0)} = Pr(W_j=1)::\\text{in terms of probabilities of }W_j }}\\\\\n &amp; = &amp; {{c2::1 - 2^{-k}::\\text{in terms of k} }}\\\\\n &amp; \\geq &amp; {{c2::\\frac12 \\text{ since } k \\geq 1}}\n\\end{array}\\]<br>",
                        "Probability of an entire clause being false with random assignment is&nbsp;\\(\\frac{1}{2^k}\\).<br><em>Source: Lecture LP4, Section 6</em>"
                    ],
                    "guid": "ttX8Dt6FYt",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Finishing off</h2>\n<ul><li>\\(E[\\text{# of sat. clauses}] = E[W] = \\sum_{j=1}^m E[W_j] \\geq {{c1::\\frac{m}{2}&nbsp;}}\\)</li><li>If there are 12 clauses and the maximum number satisfyable is 10</li><ul><li>\\(m {{c2::= 12}}\\)<br></li><li>\\(m^* {{c2::= 10}}\\)<br></li><li>\\(E[W] {{c2::\\geq 6}}\\)<br></li></ul></ul>\n",
                        "<br><em>Source: Lecture LP4, Section 7</em>"
                    ],
                    "guid": "HOm|/C]hCD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Ek-SAT</h2>\n<p>\n  What if every clause has size = 3?\n</p>\n<ul><li>Pr(\\(C_j\\)&nbsp;is satisfied) =&nbsp;{{c1::\\(\\frac78\\)}}</li><ul><li>approx for max-E3-SAT:&nbsp;{{c1::\\(\\frac78\\)}}</li></ul><li>What if size = k?</li><ul><li>approx for max-Ek-SAT:&nbsp;{{c2::\\((1-2^{-k})\\)}}</li></ul></ul>\n",
                        "Ek-SAT is \"Exact k SAT\". For instance if k=3, then it is 3 SAT where every clause has 3 variables.<br>Even just slightly better is NP-Hard, and would prove that P=NP. So the above is optimal.<br><em>Source: Lecture LP4, Section 8</em>"
                    ],
                    "guid": "qqbx7R[rVk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Integer Programming</h2>\n<p>\n  What does Integer Linear Programming add to Linear Programming?</p>\n<ul><li>\\(\\max c^T x\\)<br></li><li>Subject To</li><ul><li>\\(Ax \\leq b\\)<br></li><li>\\(x \\geq 0\\)<br></li><li>{{c1::\\(x \\in \\mathbb{Z}^n\\)}}<br></li></ul></ul>\n",
                        "\\(x = (x_1, \\ldots , x_n)\\)&nbsp;each&nbsp;\\(x_i\\)&nbsp;is an integer in the n dimensional grid&nbsp;\\(\\mathbb{Z}^n\\)<br><em>Source: Lecture LP4, Section 9</em>"
                    ],
                    "guid": "gBHl.+HvYP",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  NP-Hard</h2>\n<p>\n  ILP is NP-Hard: Max-SAT&nbsp;\\(\\rightarrow\\)&nbsp;ILP</p>\n<ul><li>Take input f for Max-SAT</li><li>In ILP:</li><ul><li>{{c1::for each&nbsp;\\(x_i \\in f\\), add&nbsp;\\(y_i\\)&nbsp;to ILP}}<br></li><li>{{c2::for each&nbsp;\\(C_j \\in f\\), add&nbsp;\\(z_j\\)&nbsp;to ILP}}<br></li></ul><li>Constraints</li><ul><li>{{c3::\\(0 \\leq y_i \\leq 1 \\in&nbsp;\\mathbb{Z}\\)}}<br></li><li>{{c3::\\(0 \\leq z_i \\leq 1 \\in&nbsp;\\mathbb{Z}\\)}}<br></li></ul></ul>\n",
                        "<ul><li>\\(y_i = 1 \\iff x_i = T\\)<br></li><li>\\(z_j = 1 \\iff C_j\\)&nbsp;is satisfied</li></ul><em><br>Source: Lecture LP4, Section 10</em><br>"
                    ],
                    "guid": "Rb~3,AZ)pW",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>\n  Clauses</h2>\n<p>\\(C = x_5 \\lor x_3 \\lor x_6\\)<br></p>\n<ul><li>Want that if&nbsp;\\(y_5 = 0, y_3 = 0, y_6 = 0\\)&nbsp;then {{c1::\\(z_j = 0\\)}}</li><li>else&nbsp;{{c2::\\(z_j\\)&nbsp;is 0 or 1}}</li><li>\\(y_5 + y_3 + y_6\\)&nbsp;{{c3::\\(\\geq z_j\\)}}</li></ul>\n",
                        "<div><br></div><em>Source: Lecture LP4, Section 11</em><br>"
                    ],
                    "guid": "pss3p[?l-4",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Another Clause</h2>\n<p>\\(C = \\overline{x_1} \\lor x_3 \\lor x_2 \\lor \\overline{x_5}\\)<br></p>\n<ul><li>if&nbsp;{{c1::\\(y_1 = 1, y_3 = 0, y_2 = 0, y_5 =1\\)}}&nbsp;then {{c2::\\(z_j = 0\\)}}</li><li>{{c1::\\((1-y_1) + y_3 + y_2 + (1-y_5)\\)}}&nbsp;{{c2::\\(\\geq z_j\\)}}</li><li>For clause&nbsp;\\(C_j\\)</li><ul><li>{{c3::\\(C_j^+\\)}}&nbsp;= {{c4::positive literals}}<br></li><li>{{c3::\\(C_j^-\\)}}&nbsp;= {{c4::negative literals}}<br></li></ul></ul>\n",
                        "<div><br></div><em>Source: Lecture LP4, Section 12</em><br>"
                    ],
                    "guid": "hPJ*S&`i/F",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Reduction</h2>\n<p>For CNF f, ILP:</p>\n<ul><li>Objective function: {{c1::\\(\\max \\sum_{j=1}^m z_j\\)}}<br></li><li>Subject to</li><ul><li>{{c2::for all&nbsp;\\(i = 1, \\ldots, n: 0 \\leq y_i \\leq 1\\)}}<br></li><li>{{c2::for all&nbsp;\\(j = 1, \\ldots, m: 0 \\leq z_j \\leq 1\\)}}<br></li><li>{{c3::\\[\\sum_{i \\in C_j^+} y_i + \\sum_{i \\in C_j^-} (1 - y_i) \\geq z_j\\]}}<br></li><li>\\(y_i\\)'s and&nbsp;\\(z_j\\)'s are integer</li></ul></ul>\n",
                        "<div><br></div><em>Source: Lecture LP4, Section 13</em><br>"
                    ],
                    "guid": "tscCc2>Q.r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>LP Relaxation</h2>\n<p><span style=\"white-space: pre;\"></span>\\(\\xcancel{\\text{I}} \\text{LP}:\\)<br></p>\n<ul><li>\\(\\max \\sum_{j=1}^m z_j\\)<br></li><li>Subject to</li><ul><li>for all&nbsp;\\(i = 1, \\ldots, n: 0 \\leq y_i \\leq 1\\)<br></li><li>for all&nbsp;\\(j = 1, \\ldots, m: 0 \\leq z_j \\leq 1\\)<br></li><li>\\(\\sum_{i \\in C_j^+} y_i + \\sum_{i \\in C_j^-} (1 - y_i) \\geq z_j\\)<br></li><li>\\(\\xcancel{y_i\\text{'s and }z_j\\text{'s are integer}}\\)<br></li></ul></ul><div><br></div><div><ul><li>ILP solution&nbsp;{{c1::\\(y^*, z^*\\)}}</li><li>Max # of satisfied clauses in f =&nbsp;{{c2::\\(m^* = z_1^* + z_2^* + \\ldots + z_m^*\\)}}</li><li>LP solution&nbsp;{{c3::\\(\\hat y^*, \\hat z^*\\)}}</li><li>Value of objective funtion at the optimal point is&nbsp;{{c4::\\(\\hat z_1^* + \\ldots + \\hat z_m^*\\)}}</li><li>\\(m^* = z_1^* + z_2^* + \\ldots + z_m^*\\)&nbsp;{{c5::\\(\\leq\\)}}&nbsp;\\(\\hat{z}_1^* + \\hat{z}_2^* + \\ldots + \\hat{z}_m^*\\)</li></ul></div>\n",
                        "\\(y^*, z^*\\)&nbsp;are proposed optimal solution (we don't find it, just suppose it exists).\n<br>\n<em>Source: Lecture LP4, Section 14</em>"
                    ],
                    "guid": "K7d6){IrHh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>LP Relaxation</h2>\n<p>Optimal LP:&nbsp;\\(\\hat y_i^* , \\hat z_j^*\\)</p>\n<ul><li>Want integer: {{c1::\\(y_i, z_j\\)}}&nbsp;which is close to&nbsp;{{c3::\\(y_i^*, z_j^*\\)}}</li><li>Set&nbsp;\\({{c3::y_i}} = \\left\\{ \\begin{array}{rcl}\n1 &amp; \\text{with probability} &amp; {{c2::\\hat y_i^* }}\\\\\n0 &amp; \\text{with probability} &amp; {{c2::1- \\hat y_i^*}}\n\\end{array} \\right.\\)</li></ul>\n",
                        "<ul><li>The star denotes optimality.</li><li>The hat denotes LP. No hat is ILP.</li><li>\\(0 \\leq \\hat y_i^* \\leq 1\\)<br></li><li>Process is Randomized Rounding</li></ul>\n<em><br>Source: Lecture LP4, Section 15</em><br>"
                    ],
                    "guid": "GmGH,RZ^MA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Expectation</h2>\n<p>Let W = # of satisfied clauses</p>\n<ul><li>\\(w_j = \\left\\{ \\begin{array}{rcl}\n1 &amp; \\text{if } C_j&amp; \\text{is satisfied}\\\\\n0 &amp;&nbsp; &amp; \\text{if not}\n\\end{array} \\right.\\)<br></li><li>Note:&nbsp;\\(W = \\sum_{j=1}^m W_j\\)</li><li>\\(E[W] = \\sum_{j=1}^m E[W_j] = \\sum_{j=1}^m Pr(C_j \\text{sat} \\geq (1-\\frac1e) \\sum_{j=1}^m \\hat z_j^* \\geq (1-\\frac1e) m^*\\)<br></li><li>Lemma:&nbsp;{{c1::\\(Pr(C_j sat.)\\)}}&nbsp;{{c2::\\(\\geq (1 - \\frac 1e) \\hat z_j^*\\)}}</li></ul>\n",
                        "<div><br></div>\n<em>Source: Lecture LP4, Section 16</em><br>"
                    ],
                    "guid": "DF*:f=Vk:f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Lemma</h2>\n<p>Look at&nbsp;\\(C_j = (x_1 \\lor x_2 \\lor \\ldots \\lor x_k)\\)</p>\n<ul><li>\\(LP: \\hat y_i^* + \\ldots \\hat y_k^* \\geq \\hat z_j^*\\)<br></li><li>\\(Pr(C_j \\text{is sat.}) = 1 - Pr(C_j \\text{is unsat.})\\)<br></li><li>\\(Pr(C_j \\text{is unsat.}) =\\)&nbsp;{{c1::\\(\\prod_{i=1}^k (1 - \\hat y_i^*)\\)}}</li></ul>\n",
                        "<div><br></div>\n<em>Source: Lecture LP4, Section 17</em><br>"
                    ],
                    "guid": "FhHKrxIo[(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Arethmetic Mean, Geometric Mean inequality</h2>\n<p>For&nbsp;\\(w_1, \\ldots , w_k \\geq 0\\)</p>\n<ul><li>AM:&nbsp;{{c1::\\(\\frac1k \\sum_{i=1}^k w_i\\)}}</li><li>GM:&nbsp;{{c2::\\(\\left( \\prod_{i=1}^k w_i \\right)^{\\frac1k}\\)}}</li><li>{{c3::\\(AM \\geq GM\\)::Relate AM and GM}}<br></li><li>\\(w_i =\\)&nbsp;{{c4::\\(1 - \\hat y_i^*\\)}}</li><li>\\(\\left[ \\frac1k \\sum_{i=1}^k (1 - \\hat y_i^*) \\right]^k \\geq \\prod_{i=1}^k (1- \\hat y_i ^*)\\)<br></li></ul>\n",
                        "<div><br></div>\n<em>Source: Lecture LP4, Section 18</em><br>"
                    ],
                    "guid": "z.lu9FYeZ)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Analysis</h2>\n<p>\\(Pr(C_j \\text{is sat.} ) = \\)&nbsp;{{c1::\\(1 - \\prod_{i=1}^k (1 - \\hat y_i^*)\\)}}<br></p>\n<ul><li>\\(\\geq 1 - \\left[ \\frac1k \\sum_{i=1}^k (1 - \\hat y_i^* ) \\right] ^k\\)<br></li><li>\\(= 1 - \\left[ 1- \\frac1k \\sum_{i=1}^k \\hat y_i^* ) \\right] ^k\\)<br></li><ul><li>\\(\\hat y_1^* + \\ldots + \\hat y_k^* \\geq \\hat z_j^*\\)<br></li></ul><li>\\(\\geq 1- \\left( 1 - \\frac{\\hat z_j^*}{k} \\right)^k\\)<br></li></ul>\n",
                        "<div>AM-GM inequality says \"at most\" but we're doing the negative so it is \"at least\".</div>\n<em>Source: Lecture LP4, Section 19</em><br>"
                    ],
                    "guid": "yG|&-ab_K/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Calculus</h2>\n<p>Let&nbsp;\\(\\alpha =\\)&nbsp;{{c1::\\(\\hat z_j^*\\)}}</p>\n<ul><li>\\(Pr(C_j \\text{ is sat.}) \\geq 1 - (1-\\frac{\\alpha}{k})^k \\geq \\left[1- (1-\\frac1k)^k \\right] \\alpha\\)<br></li><li>Let&nbsp;\\(f(\\alpha) = 1 - \\left(1-\\frac{\\alpha}{k}\\right)^k\\)</li><li>Claim:&nbsp;\\(f(\\alpha) \\geq \\left(1-\\left(1-\\frac1k\\right)^k\\right)\\alpha = \\beta \\alpha\\)</li><li>Proof:&nbsp;\\(f'' (\\alpha) \\lt 0\\)</li></ul>\n",
                        "<div><em>Source: Lecture LP4, Section 20</em><br></div>"
                    ],
                    "guid": "ofU|BhU:s)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Finishing up</h2>\n<p>\\(Pr(C_j \\text{ is sat.}) = 1 - \\prod_i (1-\\hat y_i^*)\\)</p>\n<ul><li>\\(\\geq 1 - (1-\\frac{\\hat z_j^*}{k})^k\\)<br></li><li>\\(\\geq \\left[1-(1-\\frac1k)^k\\right] \\hat z_j^*\\)<br></li><li>\\(\\geq\\)&nbsp;{{c1::\\((1-\\frac1e) \\hat z_j^*\\)}}</li></ul>\n",
                        "<div>Taylor series for&nbsp;\\(e^{-x}\\):</div><div><ul><li>\\(e^{-x} = 1 - x + \\frac{x^2}{2}-\\frac{x^3}{3!} \\pm \\ldots\\)<br></li><li>\\(e^{-x} \\geq 1 - x\\)<br></li></ul></div><div><em>Source: Lecture LP4, Section 21</em><br></div>"
                    ],
                    "guid": "toce`$|~r@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Summary</h2>\n<p>Take NP-hard problem:</p>\n<ul><li>Reduce {{c1::to ILP}}</li><li>Relax to {{c2::LP &amp; solve}}</li><li>Randomized round to get {{c3::a feasible point in ILP}}</li><ul><li>{{c3::Point is hopefully a reasonable heuristic}}</li></ul></ul>\n",
                        "<div><div><em>Source: Lecture LP4, Section 22</em><br></div></div>"
                    ],
                    "guid": "DXN:z{K64p",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Comparison</h2>\n<p>Max-SAT on Ek-SAT</p>\n<table border=\"1\" cellpadding=\"5\">\n<tbody>\n<tr>\n<td>&nbsp;</td>\n<td>&nbsp;</td>\n<td>Simple</td>\n<td>LP-based</td>\n</tr>\n<tr>\n<td rowspan=\"4\">k</td>\n<td>1</td>\n<td>&nbsp;{{c1::\\(\\frac12\\)}}</td>\n<td>{{c2::\\(1\\)}}&nbsp;</td>\n</tr>\n<tr>\n<td>2</td>\n<td>{{c1::\\(\\frac34\\)}}&nbsp;</td>\n<td>{{c2::\\(\\frac34\\)}}&nbsp;</td>\n</tr>\n<tr>\n<td>3</td>\n<td>{{c1::\\(\\frac78\\)}}&nbsp;</td>\n<td>{{c2::\\(1-(\\frac23)^3 \\approx .704\\)}}&nbsp;</td>\n</tr>\n<tr>\n<td>k</td>\n<td>&nbsp;{{c1::\\(1-2^{-k}\\)}}</td>\n<td>{{c2::\\(1-(1-\\frac1k)^k\\)}}&nbsp;</td>\n</tr>\n</tbody>\n</table>\n",
                        "<div><div><em>Source: Lecture LP4, Section 23</em><br></div></div>"
                    ],
                    "guid": "K,hM[f~#T{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Max-SAT Approximation</h1>\n<h2>Best of 2</h2>\n<p>Given f:</p><ul><li>{{c1::Run simple algorithm to get&nbsp;\\(m_1\\)}}</li><li>{{c1::Run LP scheme to get&nbsp;\\(m_2\\)}}</li><li>{{c1::Take better of 2}}</li><li>\\(E[\\max\\{m_1, m_2\\}]\\)&nbsp;{{c2::\\(\\geq \\frac34 m^* \\Rightarrow \\frac34 \\text{ approx. alg.}\\)}}</li></ul>\n",
                        "<div><div><em>Source: Lecture LP4, Section 23</em><br></div></div>"
                    ],
                    "guid": "xcY7u%;z;k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "LP4"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f67fdc0-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "Screen Shot 2022-03-17 at 4.35.51 PM.png",
                "Screen Shot 2022-03-17 at 4.36.57 PM.png",
                "Screen Shot 2022-03-17 at 4.39.43 PM.png",
                "Screen Shot 2022-03-17 at 4.39.53 PM.png",
                "Screen Shot 2022-03-17 at 6.21.19 PM.png",
                "Screen Shot 2022-03-17 at 6.28.48 PM.png",
                "antiParallel.svg",
                "antiParallelFixed.svg",
                "antiParallelUnlabeled.svg",
                "flowSize.svg",
                "flownet0.svg",
                "flownet1.svg",
                "maxFlowInputFlowNetwork.svg"
            ],
            "name": "MF1: Ford-Fulkerson Algorithm",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>General Max-Flow Problem</p>\n<ul>\n  <li>Input: {{c1:: (flow network)\n    <ul><li>directed \\(G = (V, E)\\)</li><li>\\(s \\in V\\) (starting source vertex)</li><li>\\(t \\in V\\) (ending sink vertex)</li><li>positive edge capacities&nbsp;\\(c_e {\\gt} 0\\)</li></ul>}}</li><li>Output: {{c4::flows \\(f_e\\) for \\(e \\in E\\) that is of max size}}</li><li>Running Time:</li>{{c3::<ul><li>\\(O(mC)\\) for Ford-Fulkerson</li><li>\\(O(m^2n)\\) for Edmonds-Karp</li></ul>}}</ul>",
                        ""
                    ],
                    "guid": "ApQC-GAZn.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Ford-Fulkerson vs. Edmonds-Karp Algorithms</p><p><u>Ford-Fulkerson</u></p><ul><li>main idea: {{c1::find augmenting paths using DFS or BFS}}</li><li>runtime: {{c2::\\(O(mC)\\) where \\(C\\) = size of max flow}}</li><li>assumptions: {{c3::capacities are positive integer values}}</li></ul><p><u>Edmonds-Karp</u></p><ul><li>main idea: {{c6::finds augmenting paths using BFS (example of ford-fulkerson algorithm)}}</li><li>runtime: {{c5::\\(O(m^2n)\\), stronger guarentee on running time}}</li><li>assumptions: {{c4::capacities are positive values (not necessesarily integers)}}</li></ul>",
                        ""
                    ],
                    "guid": "l?*+p:Rby_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "edmonds_karp",
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Ford-Fulkerson Algorithm Steps</p><p>Input: Flow network \\(G=(V,E)\\) with capacities \\(c_e\\) (<font color=\"#fc0107\">no requirement</font> for positive capacities)</p><ol><ol></ol><li>{{c1::Set \\(f_e = 0\\) for all \\(e \\in E\\)}}</li><li>Build the residual network \\(G^f\\) for current flow \\(f\\) (initially will be the same as input flow network)</li><ul><li>if {{c2::\\((v,w) \\in E\\) of original input flow network and \\(f_{vw} {\\lt} c_{vw}\\)}}: {{c3::add <u>original</u> edge \\((v,w)\\) to \\(G^f\\) with capacity \\(c_{vw}-f_{vw}\\)}}</li><li>if {{c2::\\((v,w) \\in E\\)&nbsp;&nbsp;of original input flow network and \\(f_{vw} {\\gt} 0\\)}}: {{c3::add <u>reverse</u> edge \\((w,v)\\) to \\(G^f\\) with capacity \\(f_{vw}\\)}}</li></ul><li>{{c6::Check for st-path \\(P\\) in \\(G^f\\) using <u><font color=\"#fc0107\">BFS or DFS</font></u></li><ul><li>if no such path exists, output \\(f\\) }}</li></ul><li>Given \\(P\\), let \\(c(P)\\) = {{c12::min capacity along \\(P\\) in \\(G^f\\)}}</li><li>Augment current flow \\(f\\) by \\(c(P)\\) units along \\(P\\)</li><ul><li>for every {{c7::forward}} edge: {{c8::increase flow along that edge by \\(c(P)\\)}}</li><li>for every {{c7::backward}} edge: {{c8::decrease flow in the reverse direction by \\(c(P)\\)}}</li></ul><li>{{c9::Repeat until no such st-path in \\(G^f\\) and output \\(f\\)}}</li></ol>",
                        "Running Time: \\(O(mC)\\)&nbsp; \"pseudo-polynomial\""
                    ],
                    "guid": "u(i9IoLn;U",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What are the inputs that make up a <u>flow network</u>?</p>",
                        "<ul><li>directed graph&nbsp;\\(G=(V,E)\\)</li><li>designated start vertex&nbsp;\\(s \\in V\\)</li><li>designated end vertex&nbsp;\\(t \\in V\\)</li><li>\\(c_e {\\gt} 0\\), positive edge capacitities for&nbsp;\\(e \\in E\\)<br></li></ul>"
                    ],
                    "guid": "u6lBljMzor",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What are the 2 <u>flow constraints</u> in the max flow problem?</p><ol><li>{{c1::<u>capacity constraint</u>: for all&nbsp;\\(e \\in E\\), \\(0 \\le f_e \\le c_e\\) (the flow of an edge must be less than or equal to the capacity of that edge)}}</li><li>{{c2::<u>conservation of flow</u>: for all&nbsp;\\(v \\in V - \\left\\{ s \\cup t \\right\\}\\) (the flow into \\(v\\) must equal the flow out of \\(v\\))}}</li></ol>",
                        "conservation of flow mathmatical expression:<br>\\[\\sum_{\\overrightarrow{wv}\\in E} f_{wv}= \\sum_{\\overrightarrow{vz}\\in E}^{} f_{vz}\\]"
                    ],
                    "guid": "B}4=om;c0V",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What is the <u>capacity constraint</u> on flows?</p>",
                        "for all&nbsp;\\(e \\in E\\), \\(0 \\le f_e \\le c_e\\) (the flow of an edge must be less than or equal to the capacity of that edge)"
                    ],
                    "guid": "sP4?.C(VSf",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What is the <u>conservation of flow constraint</u> on flows?</p>",
                        "conservation of flow: for all&nbsp;\\(v \\in V - \\left\\{ s \\cup t \\right\\}\\) (the flow into \\(v\\) must equal the flow out of \\(v\\))<br><br>\\[\\sum_{\\overrightarrow{wv}\\in E} f_{wv}= \\sum_{\\overrightarrow{vz}\\in E} f_{vz}\\]"
                    ],
                    "guid": "o)k+9Ck$dc",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What does the <u>size</u> of a flow represent in a max-flow problem? How can you calculate it?</p>",
                        "The <u>size</u> of a flow is the total flow sent through the network.&nbsp;<br><br>\\(size(f) =\\) flow-out of \\(s\\) \\(=\\) flow-in to \\(t\\)<br><br>\\(size(f) = f^{out}(s)=f^{in}(t)\\)"
                    ],
                    "guid": "Q=$jC)i/>4",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<!--\ndigraph {\n    S [pos=\"0,0!\"]\n    A [pos=\"2,1!\"]\n    B [pos=\"2,0!\"]\n    C [pos=\"2,-1!\"]\n    D [pos=\"4,1!\"]\n    E [pos=\"4,0!\"]\n    F [pos=\"4,-1!\"]\n    T [pos=\"6,0!\"]\n  S->A [label=6 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">6</font>>]\n  S->B [label=1 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">4</font>>]\n  S->C [label=5 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">5</font>>]\n  A->D [label=5 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">8</font>>]\n  A->E [label=1 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">2</font>>]\n  B->E [label=1 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">1</font>>]\n  C->F [label=7 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">8</font>>]\n  D->C [label=2 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">3</font>>]\n  D->T [label=5 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">5</font>>]\n  E->D [label=6 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">2</font>>]\n  F->E [label=0 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">3</font>>]\n  F->T [label=7 fontcolor=green xlabel=6 xlabel=<<font color=\"red\">7</font>>]\n}\n-->\n<h1>Max-Flow</h1><p>What is \\(size(f)\\) of the following flow network?&nbsp;</p><p>The <font color=\"#108001\">green</font> number on an edge is the flow of that edge (\\(f_e\\)) and the <font color=\"#fc0107\">red</font> number of the capacity of that edge (\\(c_e\\)).&nbsp;\\(f_e/c_e\\)</p><h1><img src=\"flowSize.svg\"><br></h1>",
                        "<b><u>12</u></b><br><br>The <u>size</u> of a flow is the total flow sent through the network.&nbsp;<br><br>\\(size(f) =\\) flow-out of \\(s\\) = flow-in to \\(t\\)<br><br>flow-out of&nbsp;\\(s = 6 + 1 + 5 = 12 \\)<br>flow-in to&nbsp;\\(t = 5 + 7 = 12 \\)<br>"
                    ],
                    "guid": "F?9G#`~qlY",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>&nbsp;<u>Cycles</u> are ok in flow networks for max-flow problems.</p><p><i>True or False</i></p>",
                        "<i><b>True<br></b></i><br><i>Lecture MF1.8: Cycles are OK</i>"
                    ],
                    "guid": "u-p.DHv|ME",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What are&nbsp;<u>anti-parallel</u> edges in a graph?</p>",
                        "A set of <u>anti-parallel</u> edges are a set of dircted edges that go between two vertices in opposite directions, such as the edges between \\(a\\) and \\(b\\) in the image below.<br><h1><img src=\"antiParallelUnlabeled.svg\"><br></h1>"
                    ],
                    "guid": "D^Ym;o,ji,",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>How should <u>anti-parallel</u> edges be handled in max-flow problems?</p><img src=\"antiParallel.svg\">",
                        "You want to remove anti-parallel edges by splitting one of the edges by adding a new intermediate node on that edge, keeping the edge capacity the same on both edges. You will get the same result as the two resulting flow networks are equivalent.<br>\n<img src=\"antiParallelFixed.svg\">\n<br><br>A set of <u>anti-parallel</u> edges are a set of directed edges that go between two vertices in opposite directions."
                    ],
                    "guid": "Hlxm7:R2DH",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Define the steps to build a <u>residual network</u>&nbsp;,\\(G^f\\), in terms of a max-flow problem.</p>",
                        "\\(G^f = (V,E^f)\\)<br><br>For flow network \\(G=(V,E)\\) with \\(c_e\\) for \\(e \\in E\\) and flow \\(f_e\\) for \\(e \\in E\\):<br><ul><li>If&nbsp;\\(\\overrightarrow{vw} \\in E\\)&nbsp;of original input flow network and&nbsp;\\(f_{vw} {\\lt} c_{vw}\\)&nbsp;then: add original&nbsp;\\(\\overrightarrow{vw}\\)&nbsp;to&nbsp;\\(G^f\\)&nbsp;with capacity&nbsp;\\(c_{vw}-f_{vw}\\)<br></li><li>If&nbsp;\\(\\overrightarrow{vw} \\in E\\)&nbsp;of original input flow network and&nbsp;\\(f_{vw} {\\gt} 0\\)&nbsp;then add reverse&nbsp;\\(\\overrightarrow{wv}\\)&nbsp;to&nbsp;\\(G^f\\)&nbsp;with capacity&nbsp;\\(f_{vw}\\)<br></li></ul><br><i>Lecture MF1.13: Residual Network</i><br>"
                    ],
                    "guid": "OpV]:B%fxm",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What does \\(G^f\\) represent?</p>",
                        "The <u>residual network</u> for a max-flow problem.<br>\\(G^f = (V,E^f)\\)<br><br><br><br><i>Don't mix this up with a reverse graph, represented as </i>\\(G^R\\) (from \\(SCC\\) algorithm).<br>\\(G^R=(V,E^R)\\)"
                    ],
                    "guid": "NnkPl;y|65",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<!--\ndigraph {\n    S [pos=\"0,0!\"]\n    A [pos=\"1,1!\"]\n    B [pos=\"1,0!\"]\n    C [pos=\"1,-1!\"]\n    D [pos=\"3,1!\"]\n    E [pos=\"3,-1!\"]\n    T [pos=\"4,0!\"]\n  A->D [label=2]\n  B->A [label=10]\n  B->D [label=1]\n  C->E [label=5]\n  D->C [label=1]\n  D->E [label=1]\n  D->T [label=2]\n  E->T [label=5]\n  S->A [label=3]\n  S->B [label=3]\n  S->C [label=4]\n}\n-->\n<h1>Max-Flow</h1><p>Based on the input flow network:</p><p><img src=\"maxFlowInputFlowNetwork.svg\"><br></p><p>Return the following:</p><ul><li>\\((a)\\) A valid ending residual network&nbsp;\\(G^f=(V,E^f)\\)</li><li>\\((b)\\) A valid max flow network, \\(f\\) (or \\(f^*\\)), in a visual graph form.</li><li>\\((c)\\)&nbsp;<u>The</u>&nbsp;size of the max flow, \\(size(f)\\).</li><li>\\((d)\\) The <u>vertices</u> in each set \\(V=(L \\cup R)\\) of the <u>min st-cut</u> of the flow network.<br></li></ul>",
                        "The \\(size(f)\\) of the max flow is 7.<br><br>There are multiple valid ending residual networks and max flow networks, depending on how you choose traverse the graph. The following are two valid examples (one from the DPV textbook and one based on using strictly DFS), but there are likely&nbsp;more.&nbsp;<br><br><b><u>ALEXANDRA DFS EXAMPLE<br></u></b><br>\\((a)\\)&nbsp;ending&nbsp;<u>residual network</u>&nbsp;\\(G^f\\)&nbsp;<br><img src=\"Screen Shot 2022-03-17 at 6.28.48 PM.png\"><br>\\((b)\\)&nbsp;<u>max flow</u>&nbsp;network \\(f\\)<br><img src=\"Screen Shot 2022-03-17 at 6.21.19 PM.png\"><br>\\((c)\\)&nbsp;<u>size</u>&nbsp;of the&nbsp;<u>max flow</u>, \\(size(f)\\)<br>\\(size(f)\\) = sum of flows-out of \\(s =\\)&nbsp;sum of flows-in to \\(t\\)<br>sum of flows-out of \\(s\\) \\(= 2 + 1 + 4 = 7\\)<br>sum of flows-in to \\(t = 2 + 5 = 7\\)<br>\\(size(f) = 7\\)<br><br>\\((d)\\) The vertices in each set \\(V=(L \\cup R)\\) of the min st-cut of the flow network<br>\\(L =&nbsp; \\left\\{ S, A, B&nbsp;\\right\\} \\)<br>\\(R = \\left\\{D, C, E, T \\right\\}&nbsp;\\)<br><br><br><b><u>BOOK EXAMPLE<br></u></b>\\((a)\\)&nbsp;ending <u>residual network</u> \\(G^f\\) (ignore the dotted line; it's the <i>st-cut?</i> if you want to work that out as well)<br><img src=\"Screen Shot 2022-03-17 at 4.35.51 PM.png\"><br><br>\\((b)\\)&nbsp;<u>max flow</u> network \\(f\\)<br><img src=\"Screen Shot 2022-03-17 at 4.36.57 PM.png\"><br><br>\\((c)\\)&nbsp;<u>size</u> of the <u>max flow</u>, \\(size(f)\\)<br>\\(size(f)\\) = sum of flows-out of \\(s =\\)&nbsp;sum of flows-in to \\(t\\)<br>sum of flows-out of \\(s\\) \\(= 2 + 1 + 4 = 7\\)<br>sum of flows-in to \\(t = 2 + 5 = 7\\)<br>\\(size(f) = 7\\)<br><br>\\((d)\\) The vertices in each set \\(V=(L \\cup R)\\) of the min st-cut of the flow network<br>\\(L =&nbsp; \\left\\{ S, A, B&nbsp;\\right\\} \\)<br>\\(R = \\left\\{D, C, E, T \\right\\}&nbsp;\\)<br><br>See pages 202-203 of DPV (<i>Figures 7.4, 7.6</i>) for this worked out solution step-by-step.<br><br><img src=\"Screen Shot 2022-03-17 at 4.39.43 PM.png\"><br><img src=\"Screen Shot 2022-03-17 at 4.39.53 PM.png\">"
                    ],
                    "guid": "Q1M#+KqoBI",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>In terms of flow networks:</p><ul><li>Cycles are {{c1::<u><font color=\"#108040\">okay</font></u>}}.</li><li>Anti-parallel edges are {{c2::<font color=\"#fc0107\"><u>not okay</u></font>, they need to be removed by using an additional vertex to split one of the edges}}.</li></ul><img src=\"antiParallel.svg\"><br>",
                        "<img src=\"antiParallelFixed.svg\">\n<!--\ndigraph {\n    A [pos=\"2,1!\"]\n    B [pos=\"2,-1!\"]\n    S [pos=\"0,0!\"]\n    T [pos=\"4,0!\"]\n    A->B [label=\"2\"]\n    A->T [label=\"5\"]\n    B->A [label=\"3\"]\n    B->T [label=\"4\"]\n    S->A [label=\"7\"]\n    S->B [label=\"9\"]\n}\n\ndigraph {\n    A [pos=\"2,1!\"]\n    B [pos=\"2,-1!\"]\n    S [pos=\"0,0!\"]\n    T [pos=\"4,0!\"]\n    F [pos=\"2.5,0!\"]\n    A->B [label=\"2\"]\n    A->T [label=\"5\"]\n    B->F [label=\"3\"]\n    F->A [label=\"3\"]\n    B->T [label=\"4\"]\n    S->A [label=\"7\"]\n    S->B [label=\"9\"]\n}\n-->"
                    ],
                    "guid": "cj*mdBG6{m",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Given this flow network \\(f\\):</p><p><img src=\"flownet0.svg\"><br></p><p>Show the resulting flow network once you augment the path&nbsp;\\(S \\to C \\to D \\to T\\) by 1 unit(s).</p>\n<!--\ndigraph {\n    S [pos=\"0,0!\"]\n    A [pos=\"2,1!\"]\n    B [pos=\"2,0!\"]\n    C [pos=\"2,-1!\"]\n    D [pos=\"4,1!\"]\n    E [pos=\"4,-1!\"]\n    T [pos=\"6,0!\"]\n  A->D [label=2]\n  B->A [label=0]\n  B->D [label=1]\n  C->E [label=1]\n  D->C [label=1]\n  D->E [label=1]\n  D->T [label=1]\n  E->T [label=2]\n  S->A [label=2]\n  S->B [label=1]\n  S->C [label=0]\n}\n-->",
                        "<img src=\"flownet1.svg\"><br>Don't forget, when you augment a path in a flow network and you encounter a \"backwards\" edge (such as \\(D \\to C\\)), you <u>decrease</u> the flow (\\(f_e\\)) by the number of units along that edge.\n<!--\ndigraph {\n    S [pos=\"0,0!\"]\n    A [pos=\"2,1!\"]\n    B [pos=\"2,0!\"]\n    C [pos=\"2,-1!\"]\n    D [pos=\"4,1!\"]\n    E [pos=\"4,-1!\"]\n    T [pos=\"6,0!\"]\n  A->D [label=2]\n  B->A [label=0]\n  B->D [label=1]\n  C->E [label=1]\n  D->C [label=0 color=red]\n  D->E [label=1]\n  D->T [label=2 color=red]\n  E->T [label=2]\n  S->A [label=2]\n  S->B [label=1]\n  S->C [label=1 color=red]\n}\n-->"
                    ],
                    "guid": "Cze@WoXLYL",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f69d0c8-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "lrCut.svg",
                "stCut.svg",
                "stCut2.svg",
                "stCutLR.svg"
            ],
            "name": "MF2: Max-Flow Min-Cut",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Graphs</h1><h2>Minimum Cut</h2><p>What is a <u>cut</u>? What are <u>cut edges</u>?</p>",
                        "A <u>cut</u> of an undirected graph \\(G = (V, E)\\) is a set of edges which partition the vertices into 2 sets, say \\(S\\) and \\(\\bar{S}\\) (pronounced \"s bar\").<br><br>The <u>cut edges</u> are those edges with one endpoint in \\(S\\) and the other in&nbsp;\\(\\bar{S}\\).<br><br>\\(cut(S,\\bar{S}) = \\{{(v,w) \\in E:v\\in S, w \\in \\bar{S}}\\}\\)<br><img src=\"lrCut.svg\"><br>The edges in red cut the graph into the blue and green subgraphs."
                    ],
                    "guid": "C>n#ahE7ES",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "graphs"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>When does the Ford-Fulkerson algorithm end?</p>",
                        "The Ford-Fulkerson algorithms ends when there is <u>no augumenting st-path</u> in residual \\(G^f\\) (also referenced as \\(G^{f*}\\)).<br><br><i>Lecture MF2.2: Recap: Ford-Fulkerson</i>"
                    ],
                    "guid": "NlMdiUgLgO",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Given a flow network \\(G=(V, E)\\) and a flow \\(f\\), what is the running time to check whether or not \\(f\\) is a max flow?</p>",
                        "\\(O(n+m)\\) or&nbsp;\\(O(|V|+|E|)\\): Run BFS in the residual network. A flow is maximal when it has no&nbsp;<em>st</em>&nbsp;path in the residual network.<br><br><em>Lecture MF2.3: Quiz: Verifying Max-Flow<br>See DPV Problem 7.19 for a related practice problem.</em><br>"
                    ],
                    "guid": "A(z1@z&g8}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Given a flow network \\(G=(V, E)\\) and a flow \\(f\\), how would you check if the flow&nbsp;\\(f\\) is a valid max-flow? What is the running time?</p>",
                        "<ul><li>Check if flow \\(f\\) is a valid flow:</li><ul><li>Check if flow \\(f\\) violates the&nbsp;<u>edge capacity constraint</u>&nbsp;(\\(0 \\le f_e \\le c_e)\\) for all&nbsp;\\(e \\in E\\). If any edge&nbsp;\\(e \\in E\\) violates this, return <b><u>false</u></b>.</li><li>Check if flow&nbsp;\\(f\\) violates the&nbsp;<u>flow conservation constraint</u>&nbsp;(\\(f^{in}(v) = f^{out}(v))\\) for all&nbsp;\\(v \\in V\\). If any vertex \\(v \\in V\\) violates this, return <b><u>false</u></b>.</li></ul><li>Check if flow \\(f\\) is the maximum flow:</li><ul><li>Construct residual graph&nbsp;\\(G^f\\).</li><li>Run&nbsp;\\(explore(s,G^f)\\) from&nbsp;\\(s\\) on&nbsp;\\(G^f\\) to check if there is a path from&nbsp;\\(s\\) to&nbsp;\\(t\\) by checking the \\(visited[ \\ ]\\) array.</li><ul><li>If&nbsp;\\(visited[t] = true\\), that means&nbsp;\\(t\\) is reachable from&nbsp;\\(s\\), so there is a remaining augmenting st-path in&nbsp;\\(G^f\\); therefore,&nbsp;\\(f\\) is not the max flow, so return <b><u>false</u></b>. If we wanted to get the max-flow, we could \"resume\" the max-flow algorithm from this step.</li><li>If&nbsp;\\(visited[t] = false\\), that means&nbsp;\\(t\\) is not reachable from&nbsp;\\(s\\), so there is no remaining augmenting st-path in&nbsp;\\(G^f\\); therefore,&nbsp;\\(f\\) is the max flow, so return <b><u>true</u></b>.</li></ul></ul></ul><br><ul><br></ul>Running Time: \\(O(n+m)\\)<br><i>Note</i><br>Remember that the max-flow algorithm, such as Ford-Fulkerson, ends when there is no augmenting path from \\(s\\) to \\(t\\) in the residual graph \\(G^f\\).<br>Therefore, if \\(t\\) is not reachable from \\(s\\), there is no remaining st-path, and the max flow has been reached.<br><br><i>Lecture MF2.3: Quiz: Verifying Max-Flow -&nbsp;</i><i>Technically, the professor says \"we simply run DFS from </i>\\(s\\)<i> to check whether </i>\\(t\\)<i> is reachable from </i>\\(s\\)<i>\". This isn't the best answer because DFS doesn't take a starting vertex and you'd have to do some tinkering and/or pre/post processing to get the actual answer. Skip all the hassle and just run&nbsp;</i>\\(explore(s,G^f)\\).<br><br>"
                    ],
                    "guid": "JdxK+&0er0",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>For a flow \\(f\\), if no augmenting path in \\(G^f\\), then \\(f\\) is a {{c1::max-flow}}.</p>",
                        "<i>Lecture MF2.3</i>"
                    ],
                    "guid": "bn!J?K&~V:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>A <u>cut</u> of a graph is {{c1::a partition of vertices into two sets, \\(V=(L \\cup R)\\)}}.</p>",
                        "\\(V=(L \\cup R)\\) if you want to think of the two sets as a left side and right side. This representation might be the easiest in an exam setting where formatting or Latex is not available.<br><br>The following syntax may also be appropriate:<br>\\(V=(S_1, S_2)\\)<br>\\(V=(S, \\overline{S})\\)<br><br><i>Lecture MF2.4</i>"
                    ],
                    "guid": "PgG|x@WtHC",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>An <u>st-cut</u> of a graph is {{c1::a type of cut&nbsp;\\(V=(L \\cup R)\\) that separates \\(s\\) from \\(t\\), where \\(s \\in L, t \\in R\\) (or vice-versa)}}.</p>",
                        "The starting vertex&nbsp;\\(s \\in V\\) is in one set, such as \\(L\\), and the ending vertex&nbsp;\\(t \\in V\\) is in the other set, such as \\(R\\).<br><img src=\"stCut2.svg\"><br><i>Note</i>: The vertices in each set do not need to be connected, such as in the example above.<br><br><i>Lecture MF2.4</i>"
                    ],
                    "guid": "NtRHRop;gV",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>How do you calculate the <u>capacity</u> of an&nbsp;<u>st-cut</u>?</p>",
                        "Recall, an st-cut is a cut where&nbsp;\\(s \\in L, t \\in R\\).<br><br>The <u>capacity</u> of an st-cut is the sum the capacities (\\(c_e\\)) of all edges that go from set \\(L\\) to the set \\(R\\) (\\(L \\to R\\)) on the original input graph \\(G\\); edges from \\(R \\to L\\) do not count.<br>\\[capacity(L,R)=\\sum_{\\overrightarrow{vw} \\ \\in \\ E}^{}C_{vw} \\text{, where }v \\in L, w \\in R\\]<br><img src=\"stCut2.svg\"><br>The capacity of the st-cut shown in the above image would be the sum of the capacities of the <font color=\"#108001\">green</font> edges (\\(L \\to R\\))."
                    ],
                    "guid": "mfy=vB$=2a",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Min st-cut problem</p><ul><li>Input: {{c1::<i>flow network</i>; (directed graph \\(G=(V, E)\\), \\(s, t \\in V\\), positive capacities \\(c\\) (\\(c_e &gt; 0\\)))}}</li><li>Output: {{c2::<i>st-cut</i> \\((L, R)\\) with minimum capacity}}</li></ul>",
                        ""
                    ],
                    "guid": "raK|u{:V=W",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>What is the <u>capacity</u> of the following st-cut? (assume \\(R= \\left\\{ c,d,e,t \\right\\} \\))</p><p><img src=\"stCut.svg\"><br></p>\n<!--\ndigraph G {\n    S [pos=\"0,0!\"]\n    A [pos=\"2,1!\"]\n    B [pos=\"2,0!\"]\n    C [pos=\"2,-1!\"]\n    D [pos=\"4,1!\"]\n    E [pos=\"4,0!\"]\n    F [pos=\"4,-1!\"]\n    T [pos=\"6,0!\"]\n\tS->A [label=6 fontcolor=red fontsize=20]\n\tS->B [label=4 fontcolor=red fontsize=20]\n\tA->D [label=8 fontcolor=red fontsize=20]\n\tA->E [label=2 fontcolor=red fontsize=20]\n\tB->E [label=2 fontcolor=red fontsize=20]\n    S->C [label=5 fontcolor=red fontsize=20]\n    C->F [label=8 fontcolor=red fontsize=20]\n    D->C [label=2 fontcolor=red fontsize=20]\n    D->T [label=5 fontcolor=red fontsize=20]\n    E->D [label=3 fontcolor=red fontsize=20]\n    F->E [label=3 fontcolor=red fontsize=20]\n    F->T [label=7 fontcolor=red fontsize=20]\n}\n-->",
                        "The <u>capacity</u> is <b>27</b>.<br><br>This is computed as the sum of all edges \\((L \\to R)\\), or (\\(\\left\\{ s, a, b, f \\right\\} \\to \\left\\{ c, d, e, t \\right\\}\\)):<br><br>\\(\\begin{array}{rcl}\na \\to d &amp;=&amp; 8\\\\\na \\to e &amp;=&amp; 2\\\\\nb \\to e &amp;=&amp; 2\\\\\ns \\to c &amp;=&amp; 5\\\\\nf \\to e &amp;=&amp; 3\\\\\nf \\to t &amp;=&amp; 7\\\\\n\\end{array}\\)<br><br>\\(8 + 2 + 2 + 5 + 3 + 7 = 27\\)"
                    ],
                    "guid": "lC)FeP;)x$",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>The {{c1::size of the max flow, \\(size(f)\\),}} is equal to the capacity of {{c2::the min st-cut}}.</p>",
                        "\\(V=(L \\cup R)\\),&nbsp;\\(capacity(L,R)\\)<u><br>max-flow = min-cut theorem<br></u>size of max-flow = min capacity of a st-cut<br><br><i>Lecture MF2.6: Max-Flow = Min st-Cut</i>"
                    ],
                    "guid": "Ri%)MF1(Ay",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>How can you find the vertices of the min st-cut of a flow network?</p>",
                        "Run \\(explore(s, G^f)\\) on the residual graph \\(G^f\\) to find the vertices in set \\(L\\).&nbsp; //&nbsp;\\(O(n+m) \\to O(m) \\)<br>If \\(visited[v] = true\\) for any \\(v \\in V\\), vertex \\(v\\) is in set \\(L\\).&nbsp; &nbsp; &nbsp; //&nbsp;\\(O(n)\\)<br>Running Time:&nbsp;\\(O(n+m)\\)<br><br>Build&nbsp;\\(G^{R^f}\\), a reverse graph of residual graph \\(G^f\\).&nbsp; &nbsp; //&nbsp;\\(O(n+m)\\)<br>Run \\(explore(t, G^{R^f})\\) on the reverse residual graph \\(G^{R^f}\\) to find the vertices in set \\(R\\).&nbsp; //&nbsp;\\(O(n+m) \\to O(m) \\)<br>If \\(visited[v] = true\\) for any \\(v \\in V\\), vertex \\(v\\) is in set \\(L\\).&nbsp; &nbsp; //&nbsp;\\(O(n)\\)<br>Running Time:&nbsp;\\(O(n+m)\\)<br><br>Remember, \\(R\\) is the set of vertices&nbsp;\\(v \\in V\\) that can reach \\(t\\). This is <u>not</u> always the set of vertices that are not in \\(L\\).<br><br><br><b><u>ARCHIVE</u></b><br>Run \\(explore(v, G^f)\\) on the residual graph \\(G^f\\) for \\(v \\notin L\\) to find the vertices in set \\(R\\).&nbsp;<br>If \\(visited[t] = true\\) for any output of \\(explore(v, G^f)\\) where \\(v \\in V\\), vertex \\(v\\) is in set \\(L\\).&nbsp;<br>Running Time:&nbsp;\\(O(n(n+m))\\)<br><br><div style=\"text-align: justify;\">\\(L\\_visited[ \\ ] = explore(s, G^f)\\)<br><br></div><div style=\"text-align: justify;\">for \\(v \\in V\\):</div><div style=\"text-align: justify;\">&nbsp; if \\(L\\_visited[v] = true\\):</div><div style=\"text-align: justify;\">&nbsp; &nbsp; \\(L\\).add(\\(v\\))</div><div style=\"text-align: justify;\">&nbsp;else:<br>&nbsp; &nbsp; \\(R\\_visited[ \\ ] = explore(v, G^f)\\)<br>&nbsp; &nbsp; if \\(R\\_visited[t] = true\\):</div><div style=\"text-align: justify;\">&nbsp; &nbsp; &nbsp; \\(R\\).add(\\(v\\))</div>"
                    ],
                    "guid": "Zx&-Ayuzv",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>The residual network, \\(G^f\\), is guaranteed to be unique.</p><p><i>True or False</i></p>",
                        "<b style=\"font-style: italic;\">False</b><br><br>The residual network will differ based on the order you identify st-paths and augument each path."
                    ],
                    "guid": "w?R*Cw&/mj",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>When finding the min st-cut, if you know the vertices in the set \\(L\\), where \\(s \\in L\\), you can find the vertices in set \\(R\\), where \\(t \\in R\\), by finding the vertices in the graph that are not in \\(L\\) \\((R = V - L)\\).</p><p><i>True or False</i></p>",
                        "<!--\ndigraph {\n    s [pos=\"0,0!\"]\n    a [pos=\"2,1!\"]\n    b [pos=\"2,-1!\"]\n    c [pos=\"4,1!\"]\n    d [pos=\"4,-1!\"]\n    t [pos=\"6,0!\"]\n    s->a [label=1 fontcolor=red]\n    s->b [label=1 fontcolor=red]\n    a->s [label=6 fontcolor=red]\n    b->s [label=5 fontcolor=red]\n    c->a [label=4 fontcolor=red]\n    c->b [label=2 fontcolor=red]\n    d->a [label=2 fontcolor=red]\n    d->b [label=3 fontcolor=red]\n    c->t [label=3 fontcolor=red]\n    t->c [label=6 fontcolor=red]\n    t->d [label=5 fontcolor=red]\n}\n-->\n<b style=\"font-style: italic;\">False</b><br><br>The set of vertices in \\(R\\) of a min st-cut are the vertices that can reach \\(t\\) in the residual graph \\(G^f\\). This is not necessarily the same as all the vertices not in set \\(L\\).<br><br>To find only the set of vertices in \\(R\\), you can run explore on the reverse of the residual graph \\(explore(t, G^{R^f})\\) to find what vertices are reachable from&nbsp;\\(t\\) from the reverse graph&nbsp;\\(G^{R^f}\\), which is the same as the set of vertices that can reach&nbsp;\\(t\\) in&nbsp;\\(G^f\\).<br><img src=\"stCutLR.svg\"><br>\\(L = \\left\\{s, a, b \\right\\}\\)<i>&nbsp;and&nbsp;</i>\\(R = \\left\\{c, t\\right\\}\\).<br><br><i>See DVP Problem 7.17 as an example of a flow network that has the minimum st-cut above, where </i>\\(L = \\left\\{s, a, b \\right\\}\\)<i> and </i>\\(R = \\left\\{c, t\\right\\}\\)."
                    ],
                    "guid": "fNSsvLSdB5",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>When finding the min st-cut of a residual graph&nbsp;\\(G^f\\):</p><ul><li>Set \\(L \\ (s \\in L)\\) is the set of vertices that {{c1::are reachable from&nbsp;\\(s\\) in the residual graph \\(G^f\\)}}.</li><li>Set \\(R \\ (t \\in R)\\) is the set of vertices that {{c1::can reach&nbsp;\\(t\\) in the residual graph&nbsp;\\(G^f\\)}}.</li></ul>",
                        "<img src=\"stCutLR.svg\"><br>\n\\(L = \\left\\{s, a, b \\right\\}\\)<i>&nbsp;and&nbsp;</i>\\(R = \\left\\{c, t\\right\\}\\)."
                    ],
                    "guid": "H5Zj7)`2&:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Steps to <strong>find bottleneck</strong>&nbsp;edges in a flow network \\(G=(V,E)\\):</p><ol><li>{{c1::Find a maximum flow&nbsp;\\(f\\) on the input flow network&nbsp;\\(G\\)&nbsp;to get&nbsp;\\(G^f\\)}}</li><li>{{c1::Run&nbsp;\\(explore\\) from&nbsp;\\(s\\) in&nbsp;\\(G^f\\)&nbsp;to get&nbsp;\\(S\\)}}</li><li>{{c2::Build the reverse graph (flip edges) of&nbsp;\\(G^f\\)&nbsp;to get&nbsp;\\(G^{Rf}\\).}}</li><li>{{c2::Run&nbsp;\\(explore\\) from&nbsp;\\(t\\) in&nbsp;\\(G^{Rf}\\)&nbsp;get&nbsp;\\(T\\)}}</li><li>{{c3::For each edge&nbsp;\\(\\overrightarrow{vw} \\in E\\), output&nbsp;\\(\\overrightarrow{vw}\\) as a bottleneck edge if&nbsp;\\(v \\in S\\) and&nbsp;\\(w \\in T\\).}}</li></ol>",
                        "A&nbsp;<u>bottleneck edge</u>&nbsp;is an edge of a network if increasing its capacity results in an increase in the maximum flow.<br>The set&nbsp;\\(T\\)&nbsp;are those vertices which can reach&nbsp;\\(t\\)&nbsp;in&nbsp;\\(G^f\\).<br>Running Time:&nbsp;\\(O(m^2n)\\) if Ford-Fulkerson is used,&nbsp;\\(O(mC)\\) if Edmonds-Karp is used.<br>Steps 2-5 take&nbsp;\\(O(n+m)\\) time, so the overall running time is dominated by the running time of the maximum flow algorithm chosen in step 1.<br><br><i>See DPV Problem 7.17.</i>"
                    ],
                    "guid": "QDi<P<BSm[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "max_flow",
                        "min_cut"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f6ba22c-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "Screen Shot 2022-03-12 at 3.04.34 PM.png",
                "Screen Shot 2022-03-12 at 5.15.45 PM.png",
                "Screen Shot 2022-03-12 at 5.16.21 PM.png"
            ],
            "name": "MF3: Image Segmentation",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation Algorithm</p><ul><li>Input:</li><ul><li>{{c1::undirected \\(G = (V, E)\\) where \\(V\\) = pixels and \\(E\\) = neighboring pixels}}</li><li>{{c2::for each \\(i \\in V\\):</li><ul><li>\\(f_i\\) = likelihood/weight that pixel/vertex \\(i\\) is in the \\(f\\)oreground, \\(f_i \\ge 0\\)</li><li>\\(b_i\\) = likelihood/weight that pixel/vertex \\(i\\) is in the \\(b\\)ackground, \\(b_i \\ge 0\\)</li></ul>}}<br><li>for each \\((i, j) \\in E\\):</li><ul><li>\\(p_{ij}\\) = {{c3::separation \\(p\\)enality for edge \\((i,j)\\); the cost of separating \\(i\\) and \\(j\\) into different objects, \\(p_{i,j} \\ge 0\\)}}</li></ul></ul><li>Output: {{c4::partition \\(V = F \\cup B\\) which minimizes \\(w'(F,B)\\)}}</li>{{c4::<ul><li>\\(F\\) = forground<br></li><li>\\(B\\) = background</li></ul>}}<li>Running Time: \\(?\\)</li></ul>",
                        "<i>Notes:<br><ul><li><i>min \\(w'(F,B)\\) \\(==\\) max \\(w(F,B)\\)<br></i></li><li><i>The likelihood of a pixel being either in the foreground \\((f_i)\\)&nbsp;or background \\((b_i)\\)&nbsp;is not necessarily 1.</i></li></ul></i>"
                    ],
                    "guid": "rS@UNsWuyS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "black_box",
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>How is an image represented as input to the image segementation problem?</p>",
                        "Images are represented as an undirected graph \\(G = (V,E)\\), where:<br><ul><li>\\(V\\) = pixels (vertices)</li><li>\\(E\\) = edges that connect neighboring pixels</li></ul><br><img src=\"Screen Shot 2022-03-12 at 3.04.34 PM.png\"><br>"
                    ],
                    "guid": "tO-L`/K}jN",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>The equation to define the \"quality\" or weight of a partition on the original input is:</p><br>\\[{{c1::w(F,B)}} = {{c2::\\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_j - \\sum_{(i,j) \\in E}^{}p_{ij} }}\\]",
                        "\\((i,j) \\in E:&nbsp; \\ i \\in B, \\ j \\in F\\ or \\ j \\in B, \\ i \\in F\\)<br>different variables \\(i\\)&nbsp;and \\(j\\) are used for clarity in the first 2 terms,<br>it just means that each vertex is either in the foreground or the background"
                    ],
                    "guid": "W]${eAs{C",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>What does \\(p_{ij}\\) represent in the image segmentation problem?</p>",
                        "\\(p_{ij}\\) represents the \"separation penality\" for the edge; the cost of separating vertex \\(i\\) and \\(j\\) into different objects"
                    ],
                    "guid": "s,Tf}?^UMY",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>What are the issues in the original image segmentation problem that need to be addressed in order to reduce the problem to a min st-cut problem?</p><ol><li>{{c1::min st-cut deals with positive edge capacities, so the separation penality sum needs to be&nbsp;<u>positive</u>}}<br></li><li>{{c2::min st-cut deals with minimums, not maximums so finding the partition \\(V = F \\cup B\\) with&nbsp;<u>maximum</u>&nbsp;\\(w(F,B)\\) needs to change}}<br></li></ol>",
                        "\\[\\underline{\\text{max}}&nbsp;\\ w(F,B)=\\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_i - \\underline{\\sum_{(i,j) \\in E}^{}p_{ij}}\\]"
                    ],
                    "guid": "N@iJ{=:*:q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>Reformulation of Weights</p><p><u>original</u></p><div>\\[w(F,B)=\\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_i - \\sum_{(i,j) \\in E}^{}p_{ij} \\\\\\]<br></div>",
                        "<u>reformulation</u><br>\\[\\text{Let } L=\\sum_{i \\in V}^{}(f_i+b_i) \\text{ (the sum of likelihoods for every pixel)}\\\\\\]<br>\\[L - \\sum_{i \\in F}^{}b_i + \\sum_{j \\in B}^{}f_i = \\left[ \\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_i \\right]&nbsp;\\]<br>\\(\\text{we can substitute in for } w(F,B)\\)<br>\\[w(F,B)=\\left[ \\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_i \\right]&nbsp;- \\sum_{(i,j) \\in E}^{}p_{ij} = L- \\sum_{i \\in F}^{}b_i + \\sum_{j \\in B}^{}f_i - \\sum_{(i,j) \\in E}^{}p_{ij}\\]<br>\\[w'(F,B)=\\sum_{i \\in F}^{}b_i + \\sum_{j \\in B}^{}f_i + \\sum_{(i,j) \\in E}^{}p_{ij}\\]<br>\\[w(F,B)=L-w'(F,B)\\]<br>\\(\\text{therefore, max} \\ w(F,B) = \\text{min} \\ w'(F,B)\\)"
                    ],
                    "guid": "F+`[q:0x3D",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation</p><p>Reformulation of Weights</p><p><u>original:</u>&nbsp;\\(w(F,B)\\)</p><div>\\[w(F,B)=\\sum_{i \\in F}^{}f_i + \\sum_{j \\in B}^{}b_i - \\sum_{(i,j) \\in E}^{}p_{ij} \\\\\\]<br><u>reformulation:</u>&nbsp;\\(w'(F,B)\\)<br></div><div>{{c1::\\[w'(F,B)=\\sum_{i \\in F}^{}b_i + \\sum_{j \\in B}^{}f_i + \\sum_{(i,j) \\in E}^{}p_{ij}\\]}}<br></div>",
                        "\\(\\text{therefore, max} \\ w(F,B) = \\text{min} \\ w'(F,B)\\)<br><br>\\((i,j) \\in E:&nbsp; \\ i \\in B, \\ j \\in F\\ or \\ j \\in B, \\ i \\in F\\)<br>one vertex of the edge must be in the background and the other must be in the foreground<br><br>\\[w(F,B)=L-w'(F,B)\\]"
                    ],
                    "guid": "r70E.P]Vff",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Image Segmentation Problem Steps</p><ol><li>{{c1::Do some magic math to get the new weights from the input weights that will be used as capacities.</li><ul><li>output: \\(c' =\\) capacities&nbsp; }}</li></ul><li>{{c2::Build a flow network \\((G', c')\\)}}<br></li><li>{{c3::Run any max-flow algorithm on \\(G'=(V',E'), s', t', c'\\)&nbsp;</li><ul><li>output: \\(f'=\\) flow of max size }}</li></ul><li>{{c4::Create a residual network \\(G'^f\\) on \\(G'=(V',E'), c', f'\\)</li><ul><li>output: \\(G'^f=(V,E'^f), c'^f\\)}}</li></ul><li>{{c5::Get the partition of \\(F\\) and \\(B\\):</li><ul><li>\\(F = \\)&nbsp;run \\(explore(s')\\) on \\(G'^f\\) to get a list of all reachable vertices in the \\(F\\)oreground</li><li>\\(B = V'-F\\)&nbsp;to get a list of all reachable vertices in the \\(B\\)ackground}}</li></ul></ol><br><p></p>",
                        "<img src=\"Screen Shot 2022-03-12 at 5.15.45 PM.png\"><img src=\"Screen Shot 2022-03-12 at 5.16.21 PM.png\">"
                    ],
                    "guid": "b;^|lGTO;=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1>\n<h2>Image Segmentation Problem Steps</h2>\nBuild flow network&nbsp;\\(G' = (V', E')\\)<br>\n<ol>\n\t<li>{{c1::\\(V' =\\)&nbsp;\\(V + (s', t')\\)&nbsp; &nbsp;// add new foreground&nbsp;\\(s'\\)&nbsp;and background&nbsp;\\(t'\\)&nbsp;vertices}}<br></li><li>Build E' from E<br></li><ol><li>{{c2::make all edges bi-directional (\\(\\leftrightarrow\\)) with equal capacity weights/penalties for both directions\n\t\t<ol>\n\t\t\t<li>for&nbsp;\\((i,j) \\in E\\):\n\t\t\t\t<ol>\n\t\t\t\t\t<li>add&nbsp;\\((i,j) to E'\\)&nbsp;with&nbsp;\\(c'(i,j) = p(i,j)\\)</li>\n\t\t\t\t\t<li>add&nbsp;\\((j,i)&nbsp;to E'\\)&nbsp;with&nbsp;\\(c'(j,i) = p(i,j)\\)</li>\n\t\t\t\t</ol>\n\t\t\t</li>\n\t\t</ol>\n      }}</li><li>{{c3::connect all vertices (\\(i \\in V\\)) to the foreground vertex&nbsp;\\(s'\\)&nbsp;using the likelihood of vertex&nbsp;\\(i\\)&nbsp;in the foreground as capacity\n\t\t<ol>\n\t\t\t<li>add&nbsp;\\((s', i)\\)&nbsp;to&nbsp;\\(E'\\)&nbsp;with&nbsp;\\(c'(s', i) = f_i\\)</li>\n\t\t</ol>\n\t}}</li><li>{{c4::connect all vertices (\\(i \\in V\\)) to the background vertex&nbsp;\\(t'\\)&nbsp;using the likelihood of vertex&nbsp;\\(i\\)&nbsp;in the background as capacity\n\t\t<ol>\n\t\t\t<li>add&nbsp;\\((i, t')\\)&nbsp;to&nbsp;\\(E'\\)&nbsp;with&nbsp;\\(c'(i, t') = b_i\\)</li>\n\t\t</ol>\n\t}}</li></ol>\n\t\n\t\n</ol>",
                        ""
                    ],
                    "guid": "w@N|]HMc}M",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "image_segmentation",
                        "max_flow"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f6d4258-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "MF4: Edmonds-Karp Algorithm",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Edmonds-Karp Algorithm Steps</p><p>Input: Flow network \\(G=(V,E)\\) with <u><font color=\"#fc0107\">positive</font></u> capacities \\(c_e\\)</p><ol><li>Set \\(f_e = 0\\) for all \\(e \\in E\\)</li><li>Build the residual network \\(G^f\\) for current flow \\(f\\)</li><ul><li>if \\((v,w) \\in E\\) and \\(f_{vw} {\\lt} c_{vw}\\): add \\((v,w)\\) to \\(G^f\\) with capacity \\(c_{vw}-f_{vw}\\)</li><li>if \\((v,w) \\in E\\) and \\(f_{vw} {\\gt} 0\\): add \\((w,v)\\) to \\(G^f\\) with capacity \\(f_{vw}\\)</li></ul><li>Check for st-path \\(P\\) in \\(G^f\\) using&nbsp;<u><font color=\"#fc0107\">{{c1::BFS}}</font></u></li><ul><li>if no such path exists, output \\(f\\)</li></ul><li>Given \\(P\\), let \\(c(P)\\) = min capacity along \\(P\\) in \\(G^f\\)</li><li>Augment current flow \\(f\\) by \\(c(P)\\) units along \\(P\\)</li><ul><li>for every forward edge: increase flow along that edge by \\(c(P)\\)</li><li>for every backward edge: decrease flow in the reverse direction by \\(c(P)\\)</li></ul><li>Repeat until no such st-path in \\(G^f\\) and output \\(f\\)</li></ol>",
                        "Running Time: \\(O(m^2n)\\)<br><br><i>Other differences from Ford-Fulkerson:</i><br><ul style=\"\"><li style=\"\">Residual network \\(G^f\\) has to change in at least 1 edge.</li><li style=\"\">At least 1 edge reaches full capacity: we augment on path \\(P\\) until 1 edge reaches full capacity and it's removed from the residual graph \\(G^f\\): additional edges may be removed and others may be added.</li></ul>"
                    ],
                    "guid": "J:@uY}crwO",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "edmonds_karp",
                        "exam2",
                        "max_flow"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>When should you use Edmonds-Karp over Ford-Fulkerson?</p>",
                        "You should use Edmonds-Karp if:<br><ul><li>You have non-integer capacity weights (Ford-Fulkerson assumes positive integer capacities, Edmonds-Karp only assumes positive capacities, not strictly integers).<br></li><li>You cannot bound&nbsp;\\(C\\), based on the problem inputs, that would make the running time of Ford-Fulkerson (\\(O(mC)\\)) faster than the polynomial time of Edmonds-Karp&nbsp;\\(O(m^2n)\\)</li></ul><br>Ford-Fulkerson Running Time:&nbsp;\\(O(mC)\\)&nbsp;<br>Edmonds-Karp Running TIme:&nbsp;\\(O(m^2n)\\)"
                    ],
                    "guid": "x8zr([sS6(",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "edmonds_karp",
                        "exam2",
                        "ford_fulkerson",
                        "max_flow"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f6eef22-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "MF5: Max-Flow Generalization",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Max flow with demands</p><ul><li>input:</li><ul>{{c1::<li>flow network: directed \\(G=(V,E)\\)</li><li>\\(s, t \\in V\\)</li><li>capacities \\(c_e\\) (\\(c_e {\\gt} 0 \\text{ for } e \\in E\\))</li><li>demands \\(d_e\\) (\\(d_e \\ge 0\\) for \\(e \\in E\\)) </li>}}</ul><li>output:</li><ul><li>{{c2::feasible flow&nbsp;\\(f\\) where \\(d_e \\le f_e \\le c_e\\) for \\(e \\in E\\)}}</li></ul></ul>",
                        "<i>Lecture MF5.1</i>"
                    ],
                    "guid": "FyF7?)((?x",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_metadata",
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><h2>Build&nbsp;\\(G'\\)&nbsp;for Max-Flow with demands</h2><p>Steps to transform input graph \\(G=(V,E)\\), \\(d_e\\), and \\(c_e\\) into a max-flow problem (building \\(G'\\)):</p><ol><li>{{c1::Create new \"super source\" and \"super sink\" nodes&nbsp;\\(s', t'\\)}}<br></li><li>{{c2::Add an edge \\(s' \\to v\\) for \\(v \\in V\\) with capacity \\(c_e' (s' \\to v) = d^{in}(v)\\), where \\(d^{in}(v)\\) is the sum of the demands into \\(v\\)}}</li><li>{{c2::Add an edge \\(v \\to t'\\) for \\(v \\in V\\) with capacity \\(c_e' (v \\to t') = d^{out}(v)\\), where \\(d^{out}(v)\\) is the sum of the demands out of \\(v\\)}}</li><li>{{c3::Lastly, add an edge from \\(t \\to s\\), with capacity infinity \\((\\infty)\\)}}</li></ol>",
                        "<i>Lecture MF5.4-7</i>"
                    ],
                    "guid": "nhm%Y5W3*O",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p><br></p><p>What does it mean for a flow to be <u>saturated</u>?</p>",
                        "A flow \\(f\\) is <u>saturated</u> if&nbsp;\\(size(f) = D\\).<br><br>\\[D=\\sum_{e \\ \\in \\ E}d_e = \\sum_{v \\ \\in \\ V}d^{in}(v) = \\sum_{v \\ \\in \\ V}d^{out}(v)\\] or the total demands of all edges in the flow network \\(G=(V,E)\\)<br>\\(size(f) =\\) the total flow \\(= \\sum f^{out}(s) = \\sum f^{in}(t)\\)<br><br><i>Lecture MF5.8: Saturating Flows</i>"
                    ],
                    "guid": "n2anmLI#Z4",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>A flow \\(f\\) is {{c2::<u>saturated</u>}}&nbsp;if&nbsp;{{c1::\\(size(f) = D\\)}}.<br></p>",
                        "<ul><li>\\[D=\\sum_{e \\ \\in \\ E}d_e = \\sum_{v \\ \\in \\ V}d^{in}(v) = \\sum_{v \\ \\in \\ V}d^{out}(v)\\]&nbsp;</li><ul><li>or the total demands of all edges in the flow network&nbsp;\\(G=(V,E)\\)</li></ul><li>\\(G=(V,E)\\)</li><li>\\(size(f) =\\) the total flow \\(= \\sum f^{out}(s) = \\sum f^{in}(t)\\)</li></ul><br><i>Lecture MF5.8: Saturating Flows</i><br>"
                    ],
                    "guid": "1%N|]CiT,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p>Steps to determine if an input graph \\(G=(V,E)\\), \\(d_e\\), and \\(c_e\\) has a feasible flow:</p>\n<ol><li>{{c1::Build \\(G'\\)\n    <ol><li>add super nodes \\(s'\\) and \\(t'\\) and their connections to every other node</li><li>calculate \\(c_e'\\) for \\(e \\in E\\)</li><li>add edge \\(t \\to s = infinity\\)</li>\n  </ol>}}\n  </li><li>{{c2::Run a max-flow algorithm (FF or EK) on \\(G'\\)}}</li><li>{{c3::check if we obtain a <u>saturating flow</u> (\\(size(f') = D\\)).</li><ol><li>Transform saturating flow in \\(G'\\) into a feasible flow for \\(G\\).</li></ol>}}</ol>",
                        "<ul><li><u>Build&nbsp;</u>\\(G'\\)</li><ul><li>add super source node s', connect to all other vertices, with \\(c_e'\\) of each edge = sum of demand on edges going into each v</li><li>add super sink node t', connect all other vertices to t', with \\(c_e'\\) of each edge = sum of demand on edges going out of&nbsp; each v</li><li>add edge \\(t' \\to s'\\) with capacity infinity</li><li>add \\(c_e'\\) for all internal edges where \\(c_e' = c_e - d_e\\)</li></ul><li><u>check if we obtain a saturating flow</u><br></li><ul><li>get \\(f'\\) from output of max-flow algorithm, size(f') = sum of \\(flow^{out}(s)\\) in \\(G'\\)&nbsp;</li><li>get&nbsp;\\(D\\) by obtaining the sum of all capacities on edges going out from s in \\(G\\)</li><li>if \\(size(f') = D\\), we have a saturating flow.</li></ul></ul>"
                    ],
                    "guid": "QB(~KgUk$#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Max-Flow</h1><p><br></p><p>Steps to transform a saturating flow \\(f'\\) of \\(G'\\) into a feasible flow for \\(G\\):</p><ol><li>{{c1::TODO}}</li></ol>",
                        "<i>Lecture MF5.9-14</i>"
                    ],
                    "guid": "y1[,ZQIvEV",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "algorithm_steps",
                        "exam2",
                        "max_flow",
                        "max_flow_generalization"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f7094d0-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "P_np_np-complete_np-hard.svg",
                "fa10536b41ec48fcb83bca9d3d1a688c-ao-1-A.svg",
                "fa10536b41ec48fcb83bca9d3d1a688c-ao-1-Q.svg",
                "fa10536b41ec48fcb83bca9d3d1a688c-ao-2-A.svg",
                "fa10536b41ec48fcb83bca9d3d1a688c-ao-2-Q.svg",
                "fa10536b41ec48fcb83bca9d3d1a688c-ao-O.svg",
                "graphviz-bcb1c1bfe1f281ec3db013b00b85eaea2b73e911.svg",
                "reductions-labled.svg",
                "reductions-unlabled.svg"
            ],
            "name": "NP1: Definitions",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<p>An {{c1::intractable}} problem is {{c2::unlikely to be solved efficiently (polynomial in the input size)}}.</p>",
                        "<i>Source: Lecture NP1, Section 2</i>"
                    ],
                    "guid": "DxbsJV(@vA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Complexity Classes\n</h2>\n<p></p><ul><li>{{c1::NP}} = {{c2::class of all search problems (can be verified in polynomial time)}}</li><li>{{c1::P}} = {{c3::class of search problems that are solvable in polynomial time (and therefore are also verifiable in polynomial time)}}</li></ul><p></p>",
                        "Decision problems are sometimes used instead of search problems, but this course (and DPV text) prefer search problems.<br><br><i>Source: Lecture NP1, Section 3</i>"
                    ],
                    "guid": "F5gSRWlo+Z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Complexity Classes\n</h2>\n<p>A {{c1::search problem}} is {{c2::a problem in which can a solution can be verified efficiently (polynomial time)}}.</p>",
                        "Source: Lecture NP1, Section 3"
                    ],
                    "guid": "hR0~zIc`wD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Complexity Classes\n</h2>\n<p>Relate P and NP:</p>",
                        "\\[P \\subset NP\\]<br>If a solution can be generated in polynomial time then it can also be verified in polynomial time.<br><i>Source: Lecture NP1, Section 3</i>"
                    ],
                    "guid": "J.UMVu0j,2",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  P vs NP</h2>\n<p>What does P = NP mean?</p>",
                        "It is as difficult to solve a problem as it is to verify a solution.<br><i><br>Source: Lecture NP1, Section 4</i>"
                    ],
                    "guid": "orN{b~(0x4",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Search Problems</h2>\n<p>Search Problem:</p><ul><li>Form:</li><ul><li>{{c1::Given instance \\(I\\)}}</li><li>{{c1::find a solution \\(S\\) for \\(I\\) if one exists}}</li><li>{{c1::output NO if \\(I\\) has no solutions}}</li></ul><li>Requirement (to be a search problem):</li><ul><li>{{c2::If given an instance \\(I\\) and solution \\(S\\), then we can verify \\(S\\) is a solution to \\(I\\) in polynomial time}}</li></ul></ul>",
                        "Polynomial time in |I| (size of I).<br><br><i>Source: Lecture NP1, Section 5</i>"
                    ],
                    "guid": "y`k7q(7I_%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Satisfiability Problem</h2>\n<p>SAT:</p><ul><li>input:</li><ul><li>{{c1::Boolean formula <i>f</i> in CNF with \\(n\\) variables and \\(m\\) clauses}}</li></ul><li>out:</li><ul><li>{{c2::A satisfying assignment if one exists}}</li><li>{{c2::NO otherwise}}</li></ul></ul>",
                        "<i>Source: Lecture NP1, Section 6</i>"
                    ],
                    "guid": "x~Fs>EB}([",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1><br>  NP-complete problems<br></h1><br><h2><br>  Satisfiability Problem</h2><br><p>SAT:</p><ul><li>input:</li><ul><li>Boolean formula \\(f\\) in CNF with \\(n\\) variables and \\(m\\) clauses</li></ul><li>output:</li><ul><li>satisfying assignment if one exists</li><li>NO otherwise</li></ul></ul><br>Is \\(SAT \\in NP\\)?",
                        "Verifying SAT is \\(O(nm)\\) and is a search problem (verifyable in polynomial time) and therefore <b>SAT is in NP</b>.<br><i><br>Source: Lecture NP1, Section 8</i>"
                    ],
                    "guid": "ew(m+$^sz9",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Complexity Classes</h2>\n<p>The class of {{c1::questions for which an answer can be&nbsp;verified&nbsp;in polynomial time}} is&nbsp;{{c2::NP}}, which stands for {{c2::\"nondeterministic polynomial time\"}}.</p>",
                        "<i>Source: <a href=\"https://en.wikipedia.org/wiki/P_versus_NP_problem\">Wikipedia</a></i>"
                    ],
                    "guid": "I<J@y=?mJ-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "np",
                        "NP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Complexity Classes</h2>\n<p>{{c1::The general class of questions for which some&nbsp;algorithm&nbsp;can provide an answer in polynomial time}} is {{c2::\"P\" or \"class P\"}}.</p>",
                        "<i>Source: <a href=\"https://en.wikipedia.org/wiki/P_versus_NP_problem\">Wikipedia</a></i>"
                    ],
                    "guid": "g&>W1;=rt$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>{{c1::Colorings in NP}}</h2>\n<p>{{c1::k-Colorings problem}}:</p><p></p><ul><li>input:</li><ul><li>{{c2::undirected \\(G=(V,E)\\)}}</li><li>{{c2::integer \\(k {\\gt} 0\\)}}</li></ul><li>output:</li><ul><li>{{c3::Assign each vertex a color in \\(\\{1,2,...,k\\}\\) such that adjacent vertices get different colors}}</li><li>{{c3::NO if no such k-coloring exists for \\(G\\)}}</li></ul><li>k-Colorings \\(\\in\\) NP:</li><ul><li>{{c4::Given \\(G\\) &amp; a coloring, in \\(O(m)\\) check that for \\((v,w) \\in E\\), color of \\(v\\) \\(\\neq\\) color of \\(w\\)}}</li></ul><li>Problem&nbsp;\\(\\in\\)&nbsp;P:</li><ul><li>{{c5::k-Colorings is not known to be in P}}</li></ul></ul>",
                        "<i>Source: Lecture NP1, Section 9</i>"
                    ],
                    "guid": "v+N0&F6q>.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  MST in NP</h2><ul><li>input:</li><ul><li>{{c1::\\(G=(V, E)\\) with positive edge lengths}}</li></ul><li>output:</li><ul><li>{{c2::tree \\(T\\) with minimum weight}}</li></ul><li>MST \\(\\in\\) NP:</li><ul><li>{{c3::Given \\(G\\) &amp; \\(T\\)}}</li><li>{{c3::Run BFS/DFS to check that \\(T\\) is a tree, tracking the weight}}</li><li>{{c3::Run Kruskal's/Prim's to check that \\(T\\) has min weight (same weight as step 2)}}</li><li>{{c3::\\(O(m \\log n)\\)}}</li></ul><li>MST \\(\\in\\) P:</li><ul><li>{{c4::MST is a search problem (MST \\(\\in\\) NP)}}</li><li>{{c4::Can find a solution in polynomial time (use Kruskal's or Prim's)}}</li></ul></ul>",
                        "<i>Source: Lecture NP1, Section 11</i>"
                    ],
                    "guid": "tJ7b^bFx8:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP-complete problems</h1><h2>  Knapsack Optimization Problem</h2><ul><li>input:</li><ul><li>{{c1::\\(n\\) objects with integer weights \\(w_1, \\ldots , w_n\\) and integer values \\(v_1, \\ldots , v_n\\)}}</li><li>{{c1::capacity \\(B\\)}}</li></ul><li>output:</li><ul><li>{{c2::Subset \\(S\\) of objects with:}}</li><ul><li>{{c2::total weight \\(\\leq\\) B}}</li><li>{{c2::maximum total value}}</li></ul></ul><li>Problem \\(\\in\\) NP:</li><ul><li>{{c3::Knapsack is not known to be in NP}}</li></ul><li>Problem \\(\\in\\) P:</li><ul><li>{{c4::Knapsack is not known to be in P}}</li></ul></ul>",
                        "The DP Knapsack algorithm is \\(O(nB)\\). \\(B\\) is a number which requires a size of \\(\\log B\\) bits.<br><br><i>Source: Lecture NP1, Section 11</i>"
                    ],
                    "guid": "b|yoy-3#tE",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "np",
                        "NP1"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP-complete problems</h1><h2>  Knapsack-search Problem</h2>\n<ul><li>input:</li>\n  {{c1::<ul><li>\\(n\\) objects with integer weights \\(w_1, \\ldots , w_n\\) and integer values \\(v_1, \\ldots , v_n\\)</li><li>weight capacity \\(B\\)</li><li>value goal \\(g\\)</li></ul>}}\n  <li>output:</li>{{c2::<ul>\n  <li>Subset \\(S\\) of objects with:</li>\n  <ul><li>total weight \\(\\leq B\\)</li>\n    <li>total value \\(\\geq g\\)</li>\n  </ul><li>NO if no such S exists</li></ul>}}\n  <li>Problem \\(\\in\\) NP:</li><ul>{{c3::<li>\\(\\sum_{i \\in S} w_i \\leq B\\)<br></li><li>\\(\\sum_{i \\in S} v_i \\geq g\\)<br></li><li>\\(O(n) \\rightarrow \\text{Knapsack-search}\\in NP\\)</li>}}</ul><li>Problem \\(\\in\\) P:</li><ul><li>{{c4::Knapsack-search is not known to be in P}}</li></ul></ul>",
                        "If Knapsack-search could be solved in P, then Knapack would be solvable in P by doing binary search in V (the maximum value possible) and finding the maximum <i>g</i> which has a solution.<br><br><i>Source: Lecture NP1, Section 16</i>"
                    ],
                    "guid": "rUHh/A*hSD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  NP acronym for?\n</h2>\n<h3>\n    Terminology\n</h3><ul><li>NP = {{c1::nondeterministic polynomial time}}</li><ul><li>{{c3::problems that can be solved in polynomial time on a non-deterministic machine}}</li></ul><li>P = {{c2::polynomial time}}<br></li></ul>",
                        "<i>Source: Lecture NP1, Section 18</i>"
                    ],
                    "guid": "n,2C3iOp9&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  NP acronym for?\n</h2>\n<h3>\n    Terminology\n  </h3>\n<p>Non-deterministic means the ND machine is allowed to {{c1::guess at each step}}.</p>",
                        "In the <i>d</i>&nbsp;graph, a specific input always leads to a specific state. In the <i>nd</i>&nbsp;graph, it is only necessary that some path exist to the goal state.<br><img src=\"graphviz-bcb1c1bfe1f281ec3db013b00b85eaea2b73e911.svg\"><br><br><i>Source: Lecture NP1, Section 18</i>"
                    ],
                    "guid": "H:Qyc^x!%Q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  NP-completeness</h2>\n<p>If \\(P \\neq NP\\):</p><ul><li>What are the intractable problems? {{c1::NP-Complete problems}}</li><li>{{c2::All NP-Complete}} problems are not in {{c3::P}}.</li></ul>",
                        "<img src=\"P_np_np-complete_np-hard.svg\"><i><br>Source: Lecture NP1, Section 20</i>"
                    ],
                    "guid": "J)|ZNH/GFN",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  SAT is NP-complete</h2>\n<p>SAT is NP-complete means:</p><ul><li>{{c1::SAT \\(\\in\\) NP}}</li><li>If we can solve {{c2::SAT}} in {{c2::poly-time}} then we can solve every problem in {{c2::NP}} in {{c2::poly-time}}.</li></ul>",
                        "<i>Source: Lecture NP1, Section 21</i>"
                    ],
                    "guid": "wAT>0SvXj`",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Reductions</h2>\n<p>Problems A &amp; B (example A=colorings, B=SAT)</p><p>\\(A \\rightarrow B\\) or \\(A \\leq B\\) means:</p><ul><li>{{c1::Reducing A to B}}</li><li>If we can {{c2::solve B in poly-time}} then we can {{c2::use that algorithm to solve A in poly-time.}}</li></ul>",
                        "<i>Source: Lecture NP1, Section 22</i>"
                    ],
                    "guid": "CZz#z;~SeW",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  How to do a reduction</h2>\n<p>How can problem A be reduced to problem B?</p>",
                        "Suppose there is a poly-time algorithm for B (SAT in diagram) and use it to get a poly-time algorithm for A (Colorings).<br><ol><li>Translate (function f) an input I to A to an input to B: f(I)</li><li>Translate (function h) a solution S of B to a solution to A: h(S)</li><li>Pass a \"No\" result for B to a \"No\" result for A</li></ol><i><br>Source: Lecture NP1, Section 23</i><br>"
                    ],
                    "guid": "Ei^cLi:]8l",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  More on reductions</h2>\n<p>Colorings \\(\\rightarrow\\) SAT:</p><p>Need to define:</p><p></p><ul><li>{{c1::f: input for colorings <i>G, k</i> \\(\\rightarrow\\) input for SAT <i>f(G, k)</i>}}<br></li><li>{{c2::h: solution for f(G, k): <i>S</i> \\(\\rightarrow\\) solution for colorings <i>h(S)</i>}}</li></ul>",
                        "S is a solution to f(G, k) \\(\\iff\\) h(S) is a solution to (G, k)<br><i>f</i>&nbsp;and <i>h</i>&nbsp;must be polynomial time.<br><br><i>Source: Lecture NP1, Section 24</i>"
                    ],
                    "guid": "wfWZhS&~pn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Simpler Proof Approach</h2>\n<p>Suppose we know SAT is NP-Complete</p><p>To show that the Independent Sets Problem is NP-Complete:</p><ul><li>{{c1::IS \\(\\in\\) NP}}</li><li>{{c1::SAT \\(\\rightarrow\\) IS}}</li></ul>",
                        "There are known reductions for all other NP-Complete problems to SAT, so reducing SAT to IS reduces all other NP-Complete problems to IS.<br><br><i>Source: Lecture NP1, Section 26</i>"
                    ],
                    "guid": "j)O2A|f)t3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  NP Proofs - the steps</h2>\n<div>In an NP Reduction, we have a Problem B, and we want to show that it is NP-Complete. These are the required steps:</div><div><ol><li>{{c1::Demonstrate that problem B is in the class of NP problems (Problem B \\(\\in NP\\))}}</li><ul><li>{{c1::Show the steps of how to <b>verify a solution</b> to problem B <b>in polynomial time</b>. Don't forget the runtime analysis!}}</li></ul><li>{{c2::Reduce a known NP-Hard problem (A) to problem B}} </li><ol><li>{{c3::Show how an instance (input) of A is converted to B in polynomial time. }}</li><li>{{c3::Show how a solution (output) to B can be converted to a solution for A, again in polynomial time}}</li><li>{{c4::Show that a solution for B exists if-and-only-if (IFF) a solution to A exists. You must prove both parts:}} </li><ol><li>{{c4::If you have a solution to B, you have a solution to A}}</li><li>{{c4::If there is no solution for B, then no solution exists for A. This may be done via the contra-positive approach, showing that if a solution exists for A then a solution for B must exist}}</li></ol></ol></ol></div>",
                        "<i>\"You may, for the known problem, use any of the problems reviewed in the lectures or DPV Chapter 8 -- if a covered problem is believed to be NP-Hard or NP-Complete, it may be used as your known problem.\" -</i><i>Rocko<br><br></i><i>Source: Lecture NP1, Section 26</i>"
                    ],
                    "guid": "Jxpa5l6W1W",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "fa10536b41ec48fcb83bca9d3d1a688c-ao-1",
                        "<h1>NP-complete problems</h1><h2>NP-completeness</h2><p>Identify the regions in red:</p>",
                        "<img src=\"P_np_np-complete_np-hard.svg\">",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-1-Q.svg\">",
                        "",
                        "",
                        "<i>Lecture NP1, Section 20</i>",
                        "",
                        "",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-1-A.svg\">",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-O.svg\">"
                    ],
                    "guid": "Z#i]R+sX.",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "fa10536b41ec48fcb83bca9d3d1a688c-ao-2",
                        "<h1>NP-complete problems</h1><h2>NP-completeness</h2><p>Identify the regions in red:</p>",
                        "<img src=\"P_np_np-complete_np-hard.svg\">",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-2-Q.svg\" />",
                        "",
                        "",
                        "<i>Lecture NP1, Section 20</i>",
                        "",
                        "",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-2-A.svg\" />",
                        "<img src=\"fa10536b41ec48fcb83bca9d3d1a688c-ao-O.svg\" />"
                    ],
                    "guid": "j]7sWu9pI;",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP-complete problems\n</h1>\n<h2>\n  Reductions</h2>\n<p>What is the chain of reductions?</p><p><img src=\"reductions-unlabled.svg\"><br></p>",
                        "<img src=\"reductions-labled.svg\"><br><br><i>Source: Joves Notes: NP-Complete</i>"
                    ],
                    "guid": "AvBxZ?m-E/",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f72532e-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "NP2: 3SAT",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1><p><b>3SAT</b></p><p>3SAT is {{c1::NP-complete::complexity class}}.</p>",
                        "It was proved that <b>SAT</b> is <b>NP-complete</b> by Cook-Levin '71.<br><br><i>NP2.1:NP-Completeness</i>"
                    ],
                    "guid": "AV)k`L[UI!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "3sat",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1><p><b>3SAT</b></p><p>SAT is {{c1::NP-complete::complexity class}}.</p>",
                        "<i>Lecture NP2:NP-Completeness</i>"
                    ],
                    "guid": "G2^KcB*:6P",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "3sat",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1><p><b>3SAT Algorithm</b></p><ul><li>input: {{c1::Boolean formula&nbsp;\\(f\\) in CNF with&nbsp;\\(n\\) variables and&nbsp;\\(m\\) clauses where each clause has&nbsp;\\(\\le 3\\) literals.}}</li><li>output: {{c2::satisfying assignment (for each variable in \\(f\\)), if one exists; <b>NO</b> otherwise.}}</li></ul>",
                        "example formula: \\(f=(X_3) \\wedge{} (\\overline{X_2}\\vee X_3\\vee\\overline{X_1})\\wedge(X_2\\vee X_1)\\)<br><i><br><br>Lecture NP2:3SAT</i>"
                    ],
                    "guid": "k~jXDc#T<|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "3sat",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1><p><b>3SAT</b></p><p>What do you need to show in order to prove that 3SAT is NP-complete?</p><ol><li>{{c1::3SAT&nbsp;\\(\\in\\) NP - show that you can verify the output of the 3SAT algorithm in polynomial time}}</li><li>{{c2::SAT \\(\\to\\) 3SAT - show that a known NP-complete problem (such as SAT), can be reduced to 3SAT}}</li></ol>",
                        "<i>Lecture NP2.3: Proof Outline</i>"
                    ],
                    "guid": "Dn>T4=qlPe",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "3sat",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP2: 3SAT</h1>\n<h2>Sat -&gt; 3SAT</h2>\n<div>Given a clause as input to SAT, translate it to a valid input to 3SAT.</div><div>\\(C=(\\overline{x_2} \\lor x_3 \\lor \\overline{x_1} \\lor \\overline{x_4} \\lor x_5)\\)<br></div><div><ol><li>Create {{c2::2 new variables y &amp; z}}</li><li>Define&nbsp;\\(C' = ({{c2::\\overline{x_2} }} \\lor {{c2::x_3 }} \\lor {{c2::y }}) \\land ({{c2::\\overline{y} }} \\lor {{c2::\\overline{x_1} }} \\lor {{c2::z }}) \\land ({{c2::\\overline{z} }} \\lor {{c2::\\overline{x_4} }} \\lor {{c2::x_5 }})\\)</li></ol></div>",
                        "\\(C \\text{ is satisfyable} \\iff C' \\text{ is satisfyable}\\)<br><br><em>Source: Lecture NP2, Section 9</em>"
                    ],
                    "guid": "w;xGk{n[Mh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP2: 3SAT</h1>\n<h2>Big Clauses</h2>\n<div>\\(C=(a_1 \\lor a_2 \\lor \\ldots \\lor a_k)\\)&nbsp;where&nbsp;\\(a_1, a_2, \\ldots , a_k\\)&nbsp;are literals<br></div><div><ol><li>Create {{c1::\\(k-3\\)&nbsp;new variables&nbsp;\\(y_1, y_2, \\ldots , y_{k-3}\\)}}</li><li>Replace {{c1::C by k-2 clauses}}:</li><ol><li>\\(C' = (a_1 \\lor a_2 \\lor y_1) \\land (\\overline{y_1} \\lor a_3 \\lor y_2) \\land (\\overline{y_2} \\lor a_4 \\lor \\overline{y_3}) \\land \\dots \\land (\\overline{y_{k-4}} \\lor a_{k-2} \\lor y_{k-3}) \\land (\\overline{y_{k-3}} \\lor a_{k-1} \\lor a_k)\\)<br></li></ol></ol></div>",
                        "\\(C \\text{ is satisfyable} \\iff C' \\text{ is satisfyable}\\)<br><br><em>Source: Lecture NP2, Section 9</em>"
                    ],
                    "guid": "nh[Vx.#;Ne",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f73f364-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "NP3: Graph Problems",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2>\n  Independent Set Optimization Problem\n</h2>\n<p>Subset \\(S \\subset V\\) is an independent set if no edges are contained in S (i.e. for all \\(x, y \\in S, (x,y) \\notin E\\)).\n</p><ul><li>Input: {{c1::Undirected \\(G=(V,E)\\)}}</li><li>Output: {{c2::Independent set \\(S\\) of <b>maximum</b> size}}</li><li>Problem \\(\\in\\) NP:</li><ul><li>{{c3::No}}</li></ul><li>Problem \\(\\in\\) P:</li><ul><li>{{c4::No}}</li></ul></ul>",
                        "<i>Source: Lecture NP3, Section 2</i>"
                    ],
                    "guid": "s->O-3Y8FR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "np",
                        "NP3"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2>\n  {{c1::Independent Set Search}} Problem\n</h2>\n<p>Subset \\(S \\subset V\\) is an independent set if no edges are contained in S (i.e. for all \\(x, y \\in S, (x,y) \\notin E\\)).\n</p><ul><li>Input: {{c2::Undirected \\(G=(V,E)\\), goal <i>g</i>}}</li><li>Output:</li><ul><li>{{c3::Independent set \\(S\\) with size \\(|S| \\geq g\\), if exists}}</li><li>{{c3::NO otherwise}}</li></ul><li>Problem \\(\\in\\) NP-Complete:</li><ul><li>Problem \\(\\in\\) NP:</li>\n  {{c4::<ul><li>Check all pairs \\(x, y \\in S\\), verify \\((x, y) \\notin E\\). \\(O(n^2)\\)</li><li>Check \\(|S| \\geq g\\). \\(O(n)\\).</li><li>\\(O(n^2) \\rightarrow IS \\in NP\\)</li></ul>}}\n  <li>Reduce an NP-Complete problem to this problem:</li><ul><li>{{c5::3SAT \\(\\rightarrow\\) IS}}</li></ul></ul></ul>",
                        "<i>Source: Lecture NP3, Section 5</i>"
                    ],
                    "guid": "JKhc4jg}(6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP&nbsp;</h1>\n<h2>\n  NP-Hard</h2><ul><li>NP-Hard means that {{c1::a problem is at least as hard as everything in the class NP}}.</li><li>There is a reduction from {{c2::everything in the class NP}} to {{c3::the NP-Hard problem}}.</li><li>If {{c4::the NP-Hard problem}}&nbsp;can be solved in polynomial time then {{c5::everything in NP can be solved in polynomial time}}.</li><li>To be NP-Complete, a problem has to {{c6::be NP-Hard and be in NP}}.</li><li>Complete problems are {{c7::the hardest problems}} in {{c8::NP}}. Hard problems are {{c7::at least as hard as everything}} in&nbsp;{{c8::NP}}.</li></ul><p></p>",
                        "<i>Source: Lecture NP3, Section 12</i>"
                    ],
                    "guid": "ReTqGG=xoZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2>\n  Clique Search Problem</h2>\n<p>Clique = fully connected subgraph</p><p>For \\(G = (V,E), S \\subset V\\) is a clique if for all \\(x, y \\in S, (x, y) \\in E\\).</p><ul><li>Input:</li><ul><li>{{c1::\\(G=(V,E)\\)}}</li><li>{{c1::goal \\(g\\)}}</li></ul><li>Output:</li><ul><li>{{c2::\\(S \\subset V\\) where S is a clique of size \\(|S| \\geq g\\) if one exists}}</li><li>{{c2::NO otherwise}}</li></ul><li>Problem \\(\\in\\) NP-Complete:</li><ul><li>Problem \\(\\in\\) NP:</li><ul>{{c3::<li>Given input (G, g) &amp; S</li><li>for all \\(x, y \\in S\\), check that \\((x, y) \\in E \\Rightarrow O(n^2)\\)</li><li>check that \\(|S| \\geq g \\Rightarrow O(n)\\)</li><li>\\(O(n^2) \\therefore problem \\in NP\\)</li>}}</ul><li>Reduce an NP-Complete problem to this problem:</li><ul><li>{{c4::Independent Set \\(\\rightarrow\\) Clique search problem}}</li></ul></ul></ul>",
                        "<i>Source: Lecture NP3, Section 16</i>"
                    ],
                    "guid": "LyMg0jA^#I",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "definitions",
                        "exam3",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2>\n  IS \\(\\rightarrow\\) Clique reduction</h2>\n<p>How can the Independent Set problem be reduced to the Clique search problem?</p><ul><li>Key idea: {{c1::a Clique is the opposite of an Independent set}}</li><li>Observation: S is an independent set in G \\( \\iff \\)&nbsp;{{c2::S is a clique in \\(\\bar{G}\\)}}</li><li>For G=(V,E) let \\(\\bar{G}=(V,\\bar{E})\\) where: \\(\\bar{E} = \\{(x,y): (x,y) \\notin E \\}\\)</li><ul><li>\\((x, y) \\in \\bar{E} \\iff (x,y) \\in E\\)</li></ul><li>Independent Set \\(\\rightarrow\\) Clique:</li><ul><li>Given input G=(V,E) and goal g for IS problem</li><li>Let \\(\\bar{G}\\) &amp; g be input to the Clique problem</li><li>If we get solution S for Clique then return S for IS problem</li><li>If we get NO, then return NO</li></ul></ul>",
                        "<i>Source: Lecture NP3, Section 17</i>"
                    ],
                    "guid": "Hx7z}XNftk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "graph_problems",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2>\n  Vertex Cover Search Problem</h2>\n<p>For G=(V, E): \\(S \\subset V\\) is a vertex cover if it \"covers every edge\".</p><p>For every \\((x, y) \\in E\\), either \\(x \\in S\\) and/or \\(y \\in S\\).</p><ul><li>Input:</li><ul><li>{{c1::G=(V, E)}}</li><li>{{c1::budget b}}</li></ul><li>Output:</li><ul><li>{{c2::Vertex cover S of size \\(|S| \\leq b\\) if one exists}}</li><li>{{c2::NO otherwise}}</li></ul><li>Problem \\(\\in\\) NP-Complete:</li><ul><li>Problem \\(\\in\\) NP:</li><ul><li>{{c3::Given input (G, b) &amp; S}}</li><li>{{c3::For every \\((x, y) \\in E, \\geq 1\\) of x or y are in S \\(\\Rightarrow O(n + m)\\)}}</li><li>{{c3::Check that \\(|S| \\leq b \\Rightarrow O(n)\\)}}</li><li>{{c3::\\(O(n + m) \\therefore problem \\in NP\\)}}</li></ul><li>Reduce an NP-Complete problem to this problem:</li><ul><li>{{c4::Independent Set \\(\\rightarrow\\) Vertex Cover problem}}</li></ul></ul></ul>",
                        "<i>Source: Lecture NP3, Section 20</i>"
                    ],
                    "guid": "LQ,7)]XO@Y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "graph_problems",
                        "np",
                        "NP3"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2><span style=\"font-weight: 400;\">Independent Set \\(\\rightarrow\\) Vertex Cover reduction</span><br></h2>\n<p>How can Independent Set be reduced to Vertex Cover?</p><p><br></p><ul><li>Claim: {{c1::S is a vertex cover \\(\\iff \\bar{S}\\) is in independent set}}</li><li>Take vertex cover S</li><ul><li>For edge \\((x, y) \\in E\\):</li><ul><li>\\(\\geq\\) 1 of x or y are {{c2::in S}}</li><li>\\(\\leq\\) 1 of x or y are {{c2::in \\(\\bar{S}\\)}}</li></ul><li>\\(\\Rightarrow\\) no edge is contained in \\(\\bar{S}\\)</li><li>Thus \\(\\bar{S}\\) is an independent set</li></ul><li>Take independent set \\(\\bar{S}\\)</li><ul><li>For every \\((x, y) \\in E\\):</li><ul><li>\\(\\leq\\) 1 of x or y are in \\(\\bar{S}\\)</li><li>\\(\\geq\\) 1 of x or y are in S</li></ul><li>S covers every edge</li></ul><li>For input G=(V,E) &amp; g for Independent Set</li><ul><li>Let \\(b = n-g\\)</li><li>Run Vertex Cover on G, b</li><li>G has a vertex cover of size \\(\\leq n - g \\iff\\) G has an independent set of size \\(\\geq\\) g</li></ul></ul>",
                        "<i>Source: Lecture NP3, Section 23</i>"
                    ],
                    "guid": "wzul3Yo<]w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "graph_problems",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  NP Graph Problems</h1>\n<h2><span style=\"font-weight: 400;\">3SAT \\(\\rightarrow\\) Independent Set reduction</span><br></h2>\n<p>How can 3SAT&nbsp;be reduced to Independent Set?</p><p>{{c1::TODO}}</p>",
                        "<i>Source: Lecture NP3, Section 6</i>"
                    ],
                    "guid": "BVVueFSl2D",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "graph_problems",
                        "np"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f75996c-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "NP5: Halting Problem",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1>A problem that is {{c2::undecidable}}&nbsp;is one that is {{c1::computationally impossible. It is impossible to construct an algorithm for the problem.}}",
                        "An example of an undecidable problem is Alan Turing's halting problem.<br><br><i>NP5.1: Undecidability</i>"
                    ],
                    "guid": "opnKrGx0km",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "halting_problem",
                        "np"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>NP</h1>{{c3::Halting Problem}}<br><ul><li>Input: {{c1::A program&nbsp;\\(P\\) (in any language) with an input&nbsp;\\(I\\)}}</li><li>Output:&nbsp;{{c2::\\(true\\) if&nbsp;\\(P(I)\\) ever terminates;&nbsp;\\(false\\) otherwise (i.e, has an infinite loop).}}</li></ul>",
                        "The halting problem is an example of an undecidable problem; one that is computationally impossible.<br><br><i>NP5.2: Halting Problem</i>"
                    ],
                    "guid": "OdaPlZ2y;{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam3",
                        "halting_problem",
                        "np"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f7730ba-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "RA1: Modular Arithmetic",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>{{c2::\\(x\\) mod \\(N\\)}} = {{c1::the remainder when \\(x\\) is divided by \\(N\\)}}",
                        ""
                    ],
                    "guid": "F^[^DjxT]}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>\\(x\\) mod \\(N\\) = \\(r\\)&nbsp;such that {{c1::\\(qN+r =x, \\text{where } q \\text{ is the quotient of } \\frac{x}{N}\\)::... using N,q,r,x}}<br>",
                        ""
                    ],
                    "guid": "e|!$D;BFGp",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>\\(x\\) mod&nbsp;{{c1::\\(2\\)}} = the {{c2::least}} significant bit of&nbsp;\\(x\\)<br><br>\\(x \\pmod 2 = \\left\\{ \\begin{array}{cl}\n{{c3::1}} \\text{ if } x\\text{ is {{c4::odd}} }\\\\\n{{c3::0}} \\text{ if } x \\text{ is {{c4::even}} }\n\\end{array} \\right.\\)<br><br>",
                        ""
                    ],
                    "guid": "EV~}#1gX9A",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>If {{c2::\\(x \\equiv y \\pmod N\\)}} then \\({{c1::x \\bmod N}} = {{c3::y \\bmod N}}\\)<br>",
                        "Congruence modulo <i>N</i>."
                    ],
                    "guid": "QzK:9oT^dL",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>\\(\\text{if } {{c3::x\\equiv y}}\\text{ and }{{c3::a\\equiv b}}\\text{ mod }N \\text{ then... } \\)<br><br>\\( {{c1::x}}+{{c1::a}}\\equiv {{c1::y}}+{{c1::b}}\\text{ mod }N \\)<br>\\({{c2::x}}{{c2::a}}\\equiv {{c2::y}}{{c2::b}}\\text{ mod }N\\)<br>",
                        ""
                    ],
                    "guid": "t?o1zl0pb&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>\\(321 \\times 17 \\pmod{320} \\equiv {{c1::17}}\\)",
                        "<div>Here’s how to compute it:<br> Note, \\(321 \\equiv 1 \\pmod{320}\\)<br> Hence, \\(321 \\times 17 \\equiv 1 \\times 17 \\equiv 17 \\pmod{320}\\)</div><div><span style=\"color: var(--text-lightest); font-weight: bold;\"></span>Answer: 17<br><br>This solution is derived from this following attribute of modular arithmetic:<br><br>Given, \\(x \\equiv y \\text{ mod } n \\text{ and } a \\equiv b \\text{ mod } n\\):<br>\\(xa \\equiv y b \\text{ mod } n\\)<br><br>You can easily compute that:<br>\\(321 \\text{ mod } 320 = 1\\)<br><br>and knowing that<br>&nbsp;\\(x \\text{ mod } n = r \\text{ mod } n\\)<br><br>You have the first part of the attribute<br>\\(x \\equiv y \\text{ mod } n\\) (\\(321 \\equiv 1 \\text{ mod } 320 \\))<br><br>Now, you essentially solve for&nbsp;\\(b\\).<br><br>\\(17 \\equiv b \\text{ mod } 320\\)<br><br>You know that<br>&nbsp;\\(y \\text{ mod } n = r \\text{ mod } n\\)<br><br>\\(17 \\text{ mod } 320 = 17\\)<br></div>"
                    ],
                    "guid": "vz<7;-{)d+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Modular Exponentiation<br></h2><h3>Simple Algorithm</h3><p>\\[\\begin{array}{rcl} &amp; x \\mod N &amp; = a_1 \\\\<br>x^2 \\equiv&amp; {{c1::a_1 x \\mod N}} &amp; = {{c1::a_2}} \\\\<br>x^3 \\equiv &amp; {{c1::a_2 x \\mod N}} &amp; = {{c1::a_3}} \\\\<br>&amp; \\vdots &amp; \\\\<br>x^y \\equiv &amp; {{c1::a_{y-1}x \\mod N}}<br>\\end{array}\\]<br></p>",
                        "Probably don't ever need to do this, mod-exp algorithm or the repeated squaring method is way faster.<br><br><i>Lecture RA1.7: Modular Exp: Naive</i>"
                    ],
                    "guid": "uZFYx{I19t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Modular Exponentiation<br></h2><h3>Repeated Squaring</h3><p>\\[ \\begin{array}{rcl}<br> &amp; x \\pmod N &amp; = a_1 \\\\<br>x^2 \\equiv&amp; {{c1::a_1^2 \\pmod N}} &amp; = {{c1::a_2}} \\\\<br>\\ {{c1::x^4}} \\equiv &amp; {{c1::a_2^2 \\pmod N}} &amp; = {{c1::a_4}} \\\\<br>\\ {{c1::x^8}} \\equiv &amp; {{c1::a_4^2 \\pmod N}} &amp; = {{c1::a_8}} \\\\<br>&amp; \\vdots &amp;<br>\\end{array} \\]<br></p>",
                        "Multiply the <i>a</i>&nbsp;values to get the answer. e.g.:<br>\\(7^{25} \\pmod{23} \\equiv a_{16} \\times a_{8} \\times a_1 \\pmod{23}\\)<br><br><i>Lecture RA1.8: Modular Exp: Fast</i>"
                    ],
                    "guid": "P7vagF/kI_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Modular Exponentiation<br></h2><h3>Mod-exp Algorithm</h3><p><br>  mod-exp({{c1::x,y,N}})<br></p><ul><li>Inputs: {{c1::n bit integers x, y; \\(N \\geq 0\\)}}<br></li><li>Outputs: {{c2::\\(x^y \\pmod N\\)}}<br></li><li>Recurrence: \\[z = {{c3::\\text{Mod-exp}\\left( x, \\left\\lfloor \\frac{y}{2} \\right\\rfloor, N \\right)}}\\]<br>\\[\\text{return} \\left\\{ \\begin{array}{rl}\n{{c4::z^2 \\pmod N}} &amp; : {{c5::y \\text{ is even} }} \\\\\n{{c4::x z^2 \\pmod N}} &amp; : {{c5::y \\text{ is odd} }}\n\\end{array} \\right.\\]</li><li>Method: \\[{{c8::x^y}} = \\left\\{ \\begin{array}{rl}\n{{c6::\\left(x^{y/2} \\right)^2}} &amp; : {{c5::y \\text{ is even} }} \\\\\n{{c6::x\\left(x^{\\left\\lfloor y/2 \\right\\rfloor} \\right)^2}} &amp; : {{c5::y \\text{ is odd} }}\n\\end{array} \\right.\\]</li></ul>",
                        ""
                    ],
                    "guid": "BPNQw62|ty",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>\n  \\(a \\times {{c1::\\frac1a}} = 1\\)</p>",
                        ""
                    ],
                    "guid": "Bq!y@B!-04",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>\\(x\\)&nbsp;is {{c1::the multiplicative inverse}} of&nbsp;\\(z\\)&nbsp;{{c2::\\(\\bmod N\\)}}&nbsp;if {{c3::\\(xz \\equiv 1 \\pmod N\\)}}.</p>",
                        ""
                    ],
                    "guid": "x5gBOM@=gF",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>Notation:</p><ul><li>\\(x \\equiv z^{-1} \\pmod N\\)</li><li>\\(z \\equiv {{c1::x^{-1} \\pmod N}}\\)</li></ul>",
                        ""
                    ],
                    "guid": "`h2FJle>r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>Example:</p><p>\\[\\begin{array}{rcr}<br>1^{-1} &amp; \\equiv &amp; {{c1::1}} \\mod 14\\\\<br>2^{-1} &amp; \\equiv &amp; {{c2::DNE}} \\mod 14\\\\<br>3^{-1} &amp; \\equiv &amp; {{c3::5}} \\mod 14\\\\<br>4^{-1} &amp; \\equiv &amp; {{c4::DNE}} \\mod 14\\\\<br>5^{-1} &amp; \\equiv &amp; {{c5::3}} \\mod 14\\\\<br>6^{-1} &amp; \\equiv &amp; {{c6::DNE}} \\mod 14\\\\<br>7^{-1} &amp; \\equiv &amp; {{c7::DNE}} \\mod 14\\\\<br>8^{-1} &amp; \\equiv &amp; {{c6::DNE}} \\mod 14\\\\<br>9^{-1} &amp; \\equiv &amp; {{c8::11}} \\mod 14\\\\<br>10^{-1} &amp; \\equiv &amp; {{c6::DNE}} \\mod 14\\\\<br>11^{-1} &amp; \\equiv &amp; {{c8::9}} \\mod 14\\\\<br>12^{-1} &amp; \\equiv &amp; {{c6::DNE}} \\mod 14\\\\<br>13^{-1} &amp; \\equiv &amp; {{c9::13}} \\mod 14\\\\<br>\\end{array}\\]<br></p>",
                        "1, 3, 5, 9, 11, 13 share no common divisor with 14.<br>2, 4, 6, 10, 12 share a common divisor (2) with 14."
                    ],
                    "guid": "mn+zhA-N.y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>Theorem: \\(x^{-1} \\pmod{N}\\) exists iff {{c1::\\(gcd(x, N) = 1\\)}}.</p>",
                        "If \\(x\\) and \\(N\\) have no common divisors, then the \\(gcd(x, N) = 1\\). They are <i>relatively prime</i>."
                    ],
                    "guid": "qjpgsH)G?h",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Multiplicative Inverses</h2>\n<p>\\(3^{-1} \\equiv {{c1::4}} \\pmod{11}\\)<br></p><p>But there are multiple equivalents to {{c1::4}}:</p><p>{{c2::-7}}, 4, {{c3::15}}, {{c3::26}}<br></p><p>Always report \\(x^{-1} \\pmod N\\) in {{c4::\\(0, 1, ..., N-1\\)}} if it exists.</p>",
                        ""
                    ],
                    "guid": "ALfgIx{M=&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Modulo of Negative Numbers</h2>\n<p>What is the Knuth definition of modulo?</p><p>\\(\\bmod(a, n) = {{c1::a - n * \\left\\lfloor \\frac{a}{n} \\right\\rfloor}}\\)<br></p>",
                        ""
                    ],
                    "guid": "db0+h$2Q26",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Modulo of Negative Numbers</h2>\n<p>To find a negative value \\(b\\) congruent to \\(a\\) in mod \\(N\\):</p><p>Choose a \\(q\\) such that \\({{c1::qN \\geq |a|}}\\), \\(b = {{c2::a - qN}}\\)</p>",
                        ""
                    ],
                    "guid": "JKQw#I@Aqq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Euclid's Rule</h2>\n<p>For integers \\(x\\), \\(y\\) where \\(x \\geq y &gt; 0\\):</p><p>\\(gcd(x, y) = {{c1::gcd(x \\text{ mod } y, y)}}\\)</p>",
                        "\\(gcd(x, y) = gcd(x - y, y)\\)"
                    ],
                    "guid": "Ca|U]^/PO&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Euclid's GCD Algorithm</h2>\n<p>Euclid({{c1::\\(x, y\\)}}):</p><ul><li>Input: {{c1::integers \\(x\\), \\(y\\) where \\(x \\geq y \\geq 0\\)}}</li><li>Output: {{c2::\\(gcd(x, y)\\)}}</li><li>Base Case: {{c3::\\(gcd(x, 0) = x\\)}}</li><li>Recurrence: {{c4::Euclid(\\(y, x \\text{ mod } y\\))}}</li><li>Running time: {{c5::\\(O(n^3)\\)}}</li></ul>",
                        "Flipping the order of the arguments assures the value of first paramer is at least the value of the second parameter."
                    ],
                    "guid": "ORV<m0VYp1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><h2>Computing Inverses</h2>\n<p>Ext-Euclid({{c1::x, y}})</p><ul><li>Input: {{c1::integers x, y where \\(x \\geq y \\geq 0\\)}}</li><li>Output: {{c2::integers \\(d, \\alpha, \\beta\\) where \\(d = gcd(x, y)\\), and \\(d = x \\alpha + y \\beta\\)}}</li><ul><li>If d = 1, then {{c3::\\(x^{-1} \\equiv \\alpha \\pmod y\\)}} and {{c3::\\(y^{-1} \\equiv \\beta \\pmod x\\)}}</li></ul><li>Running Time: {{c4::\\(O(n^3)\\)}}</li></ul>",
                        ""
                    ],
                    "guid": "y(`,0cjT~g",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>What is \\(q\\) in the equation \\(qN+r = x\\) when \\(x\\) is <u>negative</u> and&nbsp;\\(\\left|x\\right|&nbsp;\\ge N \\)?",
                        "<h1><span style=\"font-weight: normal;\"><span style=\"font-size: 20px;\">\\(q\\) is a value such that the product of \\((q * N)\\) is slightly more negative or equal to \\(\\le\\)&nbsp;\\(x\\), or</span><br></span></h1>&nbsp;... such that the product of \\((q * N)\\) is&nbsp;the closest value to \\(x\\) that is not greater than \\(x\\)<br><br><br>"
                    ],
                    "guid": "E_:=Nt:dyo",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>What is \\(q\\) in the equation \\(qN+r = x\\) when \\(x\\) is <u>positive</u> and&nbsp;\\(x \\ge N \\)?",
                        "<h1><span style=\"font-size: 20px; font-weight: normal;\">\\(q\\) is a value that \\((q * N)\\) is \\(\\le\\) \\(x\\), or</span></h1>\\(q\\) is a value so that \\((q * N)\\)&nbsp;is the closest value to \\(x\\) that is less than or equal to \\(x\\)"
                    ],
                    "guid": "/u3dix^C;",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>What is \\(x\\) mod \\(N\\) when \\(0 \\le x &lt; N \\)?&nbsp;",
                        "\\(x\\)"
                    ],
                    "guid": "Bzt:67*q7?",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>What is \\(-x\\) mod \\(N\\) when \\(0 \\le&nbsp;\\left|-x\\right| &lt; N \\)?&nbsp;",
                        "\\(-x+N\\)"
                    ],
                    "guid": "vs~O0OjB1G",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>Modular Addition<br><br>\\({{c2::a+b \\pmod N}} \\equiv {{c1:: (a \\bmod N + b \\bmod N) \\pmod N}}\\)",
                        ""
                    ],
                    "guid": "q-x?A/:$NY",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1><span style=\"color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; float: none; display: inline !important;\"></span></h1><h1 style=\"text-align: center; max-width: 100%; color: rgb(0, 0, 0); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;\">Modular Arithmetic</h1>Modular Subtraction<br><br>{{c2::\\(a-b\\) mod \\(N\\)}} =&nbsp;{{c1:: (\\(a\\) mod \\(N - b\\) mod \\(N\\)) mod \\(N\\)}}<br>",
                        ""
                    ],
                    "guid": "k?.geah20}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>Modular Multiplication<br><br>{{c2::\\(a*b\\) mod \\(N\\)}} =&nbsp;{{c1:: (\\(a\\) mod \\(N * b\\) mod \\(N\\)) mod \\(N\\)}}<h1></h1>",
                        ""
                    ],
                    "guid": "ERH6kL$gT9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>Modular Exponentiation<br><br>{{c2::\\(a^b\\) mod \\(N\\)}} =&nbsp;{{c1:: (\\(a\\) mod \\(N)^b\\)&nbsp;mod \\(N\\)}}<h1></h1>",
                        ""
                    ],
                    "guid": "L#*2S65I@7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>Modular Exponentiation - Repeated Squaring<br><br>Use repeated squaring to compute: <br><br>\\(7^{25}&nbsp;\\) mod \\(23\\)<br><h1></h1>",
                        "<div style=\"text-align: left;\">\\(x^y \\text{ mod } n\\)<br><br></div><div style=\"text-align: left;\">1. Write the number&nbsp;\\(y\\) in binary representation.</div><div style=\"text-align: left;\">\\(25 = 11001\\) in binary</div>\\[\\underbrace{\n\\overbrace{\\textbf1}^{2^4=\\textbf{16}} \\ \\ \\overbrace{\\textbf1}^{2^3=\\textbf8} \\ \\ \\overbrace{0}^{2^2=4} \\ \\ \\overbrace{0}^{2^1=2} \\ \\ \\overbrace{\\textbf1}^{2^0=\\textbf1}\n}_{25 \\text{ in binary representation}} = 25\\]<br><div style=\"text-align: left;\"><br>2. For all the \"flipped\" bits (the positions where the bit is \\(1\\)), do repeated squaring until you complete&nbsp;\\(x^y \\text{ mod } n\\) for the highest flipped bit position.<br>- For this example, the highest flipped bit position is 16 (out of 1, 8, and 16).<br><br><div>* \\(7^1 \\) mod \\(23 = 7\\)&nbsp;&nbsp;</div><div>\\(7^2 \\equiv&nbsp;7^{2}&nbsp;\\) mod \\(23 = 3\\)&nbsp;&nbsp;</div><div>\\(7^4 \\equiv 3^{2}&nbsp;\\) mod \\(23 = 9\\)&nbsp;</div><div>* \\(7^8 \\equiv 9^{2}&nbsp;\\) mod \\(23 = 12\\)&nbsp;&nbsp;</div><div>* \\(7^{16} \\equiv 12^{2}&nbsp;\\) mod \\(23 = 6\\)&nbsp;&nbsp;<br><br>3. Multiply the outcomes from step #2 of repeated squaring technique where the \\(y\\)&nbsp;of \\(x^y\\) is a flipped bit from step #1. You can simplify as you go by taking the mod of multiplying some of the terms if the number is getting too big.</div><br>\\(7^{25} = (7^{16} \\text{ mod } 23)* (7^{8} \\text{ mod } 23)&nbsp;* (7^{1} \\text{ mod } 23)\\)</div><div style=\"text-align: left;\">\\(= 6 * 12 * 7\\)</div><div style=\"text-align: left;\">\\(=72 * 7\\)&nbsp; // the result of&nbsp;\\(72 * 7\\) will be too difficult to do in my head, so let's simpify the \\(72\\) by taking the mod</div><div style=\"text-align: left;\">\\(=(72 \\text{ mod } 23) * 7\\)</div><div style=\"text-align: left;\">\\(=3 * 7\\)<br>\\(=21\\)<br><br>4. Take the mod of the result from step #3 to find your answer.</div><div style=\"text-align: left;\">\\(21 \\text{ mod } 23 = \\ ?\\)<br><div>\\(21 \\text{ mod } 23 = 21\\)&nbsp; &nbsp;</div></div><div style=\"text-align: left;\"><br>Therefore,</div><div style=\"text-align: left;\">\\(7^{25}&nbsp;\\) mod \\(23 = 21\\)&nbsp;</div><div style=\"text-align: left;\"><br></div><div style=\"text-align: left;\">\\(x\\) mod \\(N = a_{1}\\)</div><div style=\"text-align: left;\">\\(x^2 \\equiv (a_{1})^2\\) mod \\(N = a_2\\)</div><div style=\"text-align: left;\">\\(x^4 \\equiv (a_{2})^2\\)&nbsp;mod \\(N = a_4\\)</div><div style=\"text-align: left;\">\\(x^8 \\equiv (a_{4})^2\\)&nbsp;mod \\(N = a_8\\)</div><div style=\"text-align: left;\">\\(x^{16} \\equiv (a_{8})^2\\)&nbsp;mod \\(N = a_{16}\\)</div>"
                    ],
                    "guid": "Bz%F9G$yc:",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>\n<p>\n  What is the algorithm for fast modular exponentiation? (mod-exp)\n</p>",
                        "<code>mod-exp(x, y, N):<br>&nbsp; &nbsp;if y = 0:<br>&nbsp; &nbsp; &nbsp; return 1<br>&nbsp; &nbsp;z = mod-exp(x, floor(y/2), N)<br>&nbsp; &nbsp;if y is even:<br>&nbsp; &nbsp; &nbsp; return z * z % N<br>&nbsp; &nbsp;else:<br>&nbsp; &nbsp; &nbsp; return x * z * z % N</code>"
                    ],
                    "guid": "wqcb>T+*eH",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>The multiplicative inverse of {{c2::\\(a\\)}} is&nbsp;{{c1::\\(\\frac{1}{a}\\)}}<br><h1></h1>",
                        "\\(a&nbsp;\\cdot \\frac{1}{a} = 1\\)"
                    ],
                    "guid": "ruZRM:Vw9u",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>\\(x^{-1}\\) mod \\(N\\) exists iff&nbsp;{{c1::\\(gcd(x,N) = 1\\)}}<br><h1></h1>",
                        "if&nbsp;\\(gcd(x,N) = 1\\), then we say \"\\(x\\) and \\(N\\) are <i>relatively prime</i>\"."
                    ],
                    "guid": "x^ESU|]}WL",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>The {{c2::greatest common divisor (GCD)}} of two integers \\(A\\) and \\(B\\) is&nbsp;{{c1::the largest integer that divides both \\(A\\) and \\(B\\).}}<br><br><br><h1></h1>",
                        ""
                    ],
                    "guid": "B2(8o`F=go",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><br>{{c3::Euclid's}} rule states:<br>{{c2::\\(gcd(x,y)\\)}} = {{c1::\\(gcd(x \\bmod y, y)\\)}}<br><br><h1></h1>",
                        ""
                    ],
                    "guid": "bJe9-BO~x%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>\n  What is Euclid's algorithm?\n</p>\n<code>Euclid({{c1::x, y}}):<br>&nbsp; &nbsp;// input: {{c1::integers x, y where x &gt;= y &gt;= 0}}<br>&nbsp; &nbsp;// output: {{c2::gcd(x, y)}}<br>&nbsp; &nbsp;{{c3::if y = 0}}<br>&nbsp; &nbsp; &nbsp; {{c3::return (x)}}<br>&nbsp; &nbsp;{{c4::else}}<br>&nbsp; &nbsp; &nbsp; {{c4::return Euclid(y, x mod y)}}</code>",
                        ""
                    ],
                    "guid": "opsai:I^Z?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>What is Euclid's extended algorithm?",
                        "<code>if y = 0: return (x, 1, 0)<br>(<font color=\"#fc0107\">d</font>,&nbsp;<font color=\"#fd8008\">a'</font>,&nbsp;<font color=\"#0000ff\">b'</font>) = Ext-Euclid(y, x mod y)<br>return(<font color=\"#fc0107\">d</font>,&nbsp;<font color=\"#0000ff\">b'</font>,&nbsp;<font color=\"#fd8008\">a'</font>&nbsp;-&nbsp;<span style=\"color: rgb(0, 0, 255);\">b'</span>*floor(x/y))</code>"
                    ],
                    "guid": "L:D;S^K=3Y",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>Solve \\(7^{-1} \\ mod \\ 360\\) using Euclids extended algorithm.",
                        "<code>Ext-Euclid(x, y):<br>if y==0<br>&nbsp;&nbsp;return x, 1, 0<br>d, a, b = Euclid(y, x mod y)<br>return d, b, a - b*floor(x/y)</code><br><br>\\(\\begin{array}{rcl}\n1, -2, 103 &amp;=&amp; \\text{Ext-Euclid}(360, 7)\\\\\n1, 1, -2 &amp;=&amp; \\text{Ext-Euclid}(7, 3)\\\\\n1, 0, 1 &amp;=&amp; \\text{Ext-Euclid}(3, 1)\\\\\n1, 1, 0 &amp;=&amp; \\text{Ext-Euclid}(1, 0)\\\\\n\\end{array}\\)<br><br>\\(\\begin{array}{rcl}\ny^{-1} &amp;=&amp; b \\pmod x \\\\\n7^{-1} &amp;\\equiv&amp; 103 \\pmod {360}\n\\end{array}\\)<br><br>Answer: 103"
                    ],
                    "guid": "J>u14p#*|r",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>What is Euclid's extended algorithm?<br><code>{{c1::if y = 0: return (x, 1, 0)}}<br>{{c2::(<font color=\"#fc0107\">d</font>,&nbsp;<font color=\"#fd8008\">a'</font>,&nbsp;<font color=\"#0000ff\">b'</font>) = Ext-Euclid(y, x mod y)}}<br>{{c3::return(<font color=\"#fc0107\">d</font>,&nbsp;<font color=\"#0000ff\">b'</font>,&nbsp;<font color=\"#fd8008\">a'</font>&nbsp;-&nbsp;<span style=\"color: rgb(0, 0, 255);\">b'</span>*floor(x/y))}}<br></code>",
                        ""
                    ],
                    "guid": "bH*YgfoomG",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1>\n<p>\n  What is the algorithm for fast modular exponentiation? (mod-exp)\n</p><code>mod-exp({{c1::x, y, N}}):<br>&nbsp; &nbsp;{{c2::if y = 0:}}<br>&nbsp; &nbsp; &nbsp; {{c2::return 1}}<br>&nbsp; &nbsp;{{c3::z = mod-exp(x, floor(y/2), N)}}<br>&nbsp; &nbsp;{{c4::if y is even: // if y % 2 = 0}}<br>&nbsp; &nbsp; &nbsp; {{c5::return z * z % N}}<br>&nbsp; &nbsp;{{c4::else:}}<br>&nbsp; &nbsp; &nbsp; {{c5::return x * z * z % N}}</code>",
                        ""
                    ],
                    "guid": "vEVmT/FJYE",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>Consider the recurrence relation (n &gt; 100): <br></p><ul><li>Base case: \\(A[1] = 4\\) </li><li>Recurrence: \\(A[i] = 4^{A[i−1]},1 {\\lt} i \\leq n\\)&nbsp;</li></ul><br>&nbsp;What is A[100] mod 7?&nbsp;",
                        "\\[\\begin{array}{rcl}\nA[1] &amp;=&amp; 4&nbsp; \\\\\nA[2] &amp;=&amp; 4^4 = 2^8 = 2^4 \\times 2^4 = 16 \\times 16 \\equiv 2 \\times 2 \\pmod 7 \\equiv 4 \\pmod 7&nbsp; \\\\\nA[3] &amp;=&amp; 4^{A[2]} = 4^4 \\equiv A[2] \\equiv 4 \\pmod 7&nbsp; \\\\\n&amp;\\vdots&amp;\\\\\nA[100] &amp;\\equiv&amp; 4 \\pmod 7\n\\end{array}\\]"
                    ],
                    "guid": "gv%06Fa}w.",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>What is \\(2^{32} \\pmod {11}\\)?<br></p>",
                        "11 is prime, so use Fermat's Little Theorem:<br>\\(2^{32} = \\left(2^{10}\\right)^3 \\times 2^2 = (1)^3 \\times 2^2 \\pmod {11} \\equiv 4 \\pmod {11}\\)"
                    ],
                    "guid": "bq7-rT$OTd",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>What is \\(2^{345} \\pmod {31}\\)?<br></p><p></p><ul><li>Using exponent identities?</li><ul><li>{{c1:: \\(2^{345} = 2^{5^{69} } = 32^{69} \\equiv 1^{69} \\equiv 1 \\pmod {31}\\) }}</li></ul><li>Using Fermat's Little Theorem?</li><ul><li>{{c2:: \\(2^{30} \\equiv 1 \\pmod {31} \\rightarrow 2^{345} = \\left(2^{30}\\right)^{11} \\times 2^{15} \\equiv 1^{11} \\times 2^{5^3} \\equiv 32^3 \\equiv 1 \\pmod {31}\\) }}</li></ul></ul><p></p>",
                        ""
                    ],
                    "guid": "xvEkKuJ2.^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>How would you find&nbsp;\\(3^{644} \\pmod {645}\\)?</p>",
                        "645 is composite (\\(3 \\times 5 \\times 43\\)) so Fermat's little theorem does not apply.<br>Use the modular exponentiation algorithm."
                    ],
                    "guid": "j+V!e_8@@o",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>What is \\(11^{-1} \\pmod {15}\\) given:</p><p>euclid-ext(15, 11) returns:</p><p>\\(d=1, a = 3, b = -4\\)&nbsp;</p>",
                        "\\(d = a x + b y\\)<br>When \\(d = 1: x^{-1} \\equiv a \\pmod y, y^{-1} \\equiv b \\pmod x\\)<br><br>So \\(11^{-1} \\pmod {15} \\equiv -4&nbsp; \\pmod {15}\\)<br>\\(-4 \\pmod {15} = 11\\)<br>Therefore, the answer is <b><u>11</u></b>.<br><br>"
                    ],
                    "guid": "e}3l5;QHk|",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Modular Arithmetic</h1><p>What is \\(3^{30} + 4^{40} + 5^{50} + 6^{60} \\pmod 7\\)?</p>",
                        "Use Fermat's Little Theorem:<br>\\[\\begin{array}{rcl}\n3^{30} &amp;=&amp; (3^6)^5 \\equiv 1^5 \\pmod 7 \\equiv 1 \\pmod 7\\\\\n4^{40} &amp;=&amp; (4^6)^6 \\times 4^4 \\equiv 1^6 \\times 2^2 \\times 2^2 \\pmod 7 \\equiv 4 \\pmod 7\\\\\n5^{50} &amp;=&amp; (5^6)^8 \\times 5^2 \\equiv 1^8 \\times 25 \\pmod 7\\equiv 4 \\pmod 7\\\\\n6^{60} &amp;=&amp; (2^6)^{10} \\equiv 1^{10} \\pmod 7 \\equiv 1 \\pmod 7\\\\\n\\end{array}\\]<br>So, \\(3^{30} + 4^{40} + 5^{50} + 6^{60} \\equiv 1 + 4 + 4 + 1 \\pmod 7 \\equiv 10 \\pmod 7 \\equiv 3 \\pmod 7\\)."
                    ],
                    "guid": "CZLi_!#(&[",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Randomized Algorithms</h1><p><b>RSA</b></p><p>\\(gcd(x,y) = gcd(\\){{c1::\\(x \\pmod y, y\\)}}\\()&nbsp;\\)</p>",
                        "\\(x \\ge y\\)<br><br>Euclid's Rule"
                    ],
                    "guid": "N~O=A]|4w#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "i",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Randomized Algorithms</h1><p><b>Fermat's Little Theorem</b></p><p>If p is {{c1::prime}}, and z and p are \"{{c1::relatively prime}}\", then:</p><p>{{c2::\\(z^{p-1} \\equiv 1 \\pmod p\\)}}</p>",
                        ""
                    ],
                    "guid": "p:oq}_1Ud5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "modular_arithmetic",
                        "randomized_algorithms"
                    ]
                }
            ]
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "7f79323e-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 7,
            "extendRev": 0,
            "media_files": [],
            "name": "RA2: RSA",
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Fermat's Little Theorem</h2><p>If {{c2::p is prime}} then for every \\(1 \\leq z \\leq p-1\\):</p><p>{{c1::\\(z^{p-1} \\equiv 1 \\pmod p\\)}}</p>",
                        "If p is prime then gcd(z, p) = 1."
                    ],
                    "guid": "tj=XrCq|uQ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Euler's Theorem</h2><p>For any N, z where gcd(N, z) = 1, then:</p><p>{{c1::\\(z^{\\phi (N)} \\equiv 1 \\pmod N\\)}}<br></p>",
                        ""
                    ],
                    "guid": "l:ybH46`H|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Euler's Theorem</h2><h3>\n  Euler's Totient Function\n</h3><p>\\(\\phi (N) =\\) {{c1::# of integers between 1 &amp; N which are relatively coprime to N::description}}</p>",
                        "\\(|1 \\{ x : 1 \\leq x \\leq N, gcd(x, N) = 1\\}|\\)"
                    ],
                    "guid": "CkU:RhP1,a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Euler's Theorem</h2><h3>\n  Euler's Totient Function\n</h3><p>When N is prime, what is the totient of N?</p><p>\\(\\phi (N) = {{c1::N - 1}}\\)</p>",
                        "<ul><li>A prime number by definition has no factors besides itself and 1.</li><li>When N is prime, Euler's Theorem is the same as Fermat's Little Theorem:</li><ul><li>\\(z^{\\phi N} \\equiv 1 \\pmod N\\)</li><li>\\(\\phi (p_{prime}) = p-1\\)</li><li>\\(z^{p-1} \\equiv 1 \\pmod N\\)</li></ul></ul>"
                    ],
                    "guid": "m|a<%o&DG@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Euler's Theorem</h2><h3>\n  Euler's Totient Function\n</h3><p>When \\(N\\) is a product of primes \\(p\\) and \\(q\\), what is the totient of \\(N\\)?</p><p>\\(\\phi (N) = {{c1::(p-1)(q-1)}}\\)<br></p>",
                        "From 1 to pq there are q multiples of p and p multiples of q. \\(pq - q - p + 1 = (p-1)(q-1)\\). The +1 is because item pq gets counted twice in the subraction."
                    ],
                    "guid": "r]>X-[md{Y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Euler's Theorem</h2><p>{{c3::For primes <i>p, q</i> and any <i>z</i>}}&nbsp;where {{c2::\\(gcd(z, pq) = 1\\)}} then:</p><p>{{c1::\\[\\begin{array}{rcl}<br>z^{\\phi(N)} &amp;\\equiv&amp; 1 \\pmod {N} \\\\<br>z^{(p-1)(q-1)} &amp;\\equiv&amp; 1 \\pmod {pq}<br>\\end{array}\\]&nbsp;}}</p>",
                        ""
                    ],
                    "guid": "oczfk7}7/@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Idea</h2><p>Fermat's Theorem: For prime <i>p</i> take {{c1::<i>b, c</i>}} where {{c1::\\(bc \\equiv 1 \\pmod {p-1}\\)}}. Then:</p><p>{{c2::\\(z^{bc} \\equiv z \\pmod p\\)}}<br></p>",
                        "<ul><li>b and c are inverses, mod p-1</li><li>\\(bc = 1 + k(p-1)\\) for some integer k</li><li>\\(z^{bc} \\equiv z \\times \\left( z^{p-1} \\right)^k \\equiv z \\pmod p\\)<br></li><li>This requires giving away p which in combination with b can be used to find c</li></ul>"
                    ],
                    "guid": "yhU}@HD;*k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Idea</h2><h3>Euler's Theorem</h3><p>For prime p &amp; q, let N = pq. Take {{c1::d, e}} where \\({{c1::de}} \\equiv {{c2::1 \\pmod {(p-1)(q-1)} }}\\) then</p>{{c3::\\(z^{de} \\equiv z \\pmod N\\)}}<br>",
                        "<ul><li>\\(z^{de} \\equiv z \\times \\left( z^{(p-1)(q-1)} \\right)^k \\equiv z \\times \\left( 1 \\right)^k \\equiv z \\pmod N\\)</li><li>e (encryption) and N can be public, owner knows p and q</li><li>ext-euclid can be used by owner to find d (decryption)</li></ul>"
                    ],
                    "guid": "yPYe(bY2^J",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Protocol</h2><h3>Receiver (keygen)</h3><p></p><ol><li>{{c1::Bob picks 2 n-bit random primes p &amp; q}}</li><li>{{c2::Bob chooses e relatively prime to (p-1)(q-1)}}</li><li>{{c3::Bob publishes his public key (N, e)}}</li><li>{{c4::Bob computes his private key \\(d \\equiv e^{-1} \\pmod {(p-1)(q-1)}\\)}}</li></ol><p></p>",
                        "\\(N = pq\\)"
                    ],
                    "guid": "deLySp@$Q:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Protocol</h2><h3>Sender</h3><p>Alice wants to send \\(M\\) to Bob</p><ol><li>{{c1::Looks up Bob's public key (\\(N, e\\))}}</li><li>{{c2::She computes \\(C \\equiv M^e \\pmod N\\)}}</li><li>{{c3::She sends \\(C\\)}}</li></ol><p></p>",
                        "\\(e\\)&nbsp;may be large but Alice can use the fast mod-exp algorithm."
                    ],
                    "guid": "G-()!sHQf{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Protocol</h2><h3>Receiver</h3><ol><li>Bob receives y</li><li>Decrypts: computes \\({{c1::y^d \\bmod N}} = m\\)</li></ol>",
                        "Recall:<br><ul><li>\\(d \\equiv e^{-1} \\bmod {(p-1)(q-1)}\\)</li><li>\\(\\Rightarrow de = 1 + k(p-1)(q-1)\\)<br></li><li>\\((y)^d \\equiv \\left(m^e\\right)^d \\equiv m^{ed} \\equiv m \\times \\left( m^{(p-1)(q-1)} \\right)^k \\equiv m \\times \\left( 1 \\right)^k \\equiv m \\pmod N\\)<br></li></ul>"
                    ],
                    "guid": "Es#I`3peZr",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>RSA Pitfalls</h2><ol><li>{{c1::m and N are not relatively prime; gcd(m, N) &gt; 1}}</li><li>{{c1::m too large}}</li><li>{{c1::m too small}}</li><li>{{c1::Send same m, e times}}</li></ol>",
                        "<ol><li>Check that m and N are relatively prime</li><li>m needs to be less than N</li><ol><li>Break m into chunk of size less than n where \\(N \\geq 2^n\\)</li></ol><li>If \\(m^e &lt; N\\) then the mod isn't doing anything. e is commonly 3, so it's easy for an eavesdropper to check&nbsp;\\(\\sqrt[3]{m}\\)</li><ol><li>Pad (or xor) m with r and send r separately</li></ol><li>An attacker can use the Chinese Remainder Theorem on \\(y_1, y_2, y_3\\) to recover m</li></ol>"
                    ],
                    "guid": "fC=W<It47(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Fermat Witnesses</h2><p><i>z</i>&nbsp;is a Fermat witness for \\(r\\) if {{c1::\\(1 \\leq z \\leq r - 1\\)}} &amp; {{c2::\\(z^{r-1} \\not\\equiv 1 \\pmod r\\)}}</p><p>\\(z\\) is a {{c3::non-trivial}} witness if {{c4::\\(gcd(z, r) = 1\\)}}.</p>",
                        "A composite \\(r\\) has \\(\\geq 1\\) Fermat Witness."
                    ],
                    "guid": "LFo{f#xa|I",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>\\({{c2::\\phi N}} = {{c1::\\left| {x:1\\le x \\le N, gcd(x,N)=1} \\right|}}\\)",
                        "\\(\\phi N =\\) the # of integers between \\(1\\) and \\(N\\) that are <i>relatively prime</i> to \\(N\\), meaning \\(gcd(x,N)=1\\)"
                    ],
                    "guid": "A&qk.3saui",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>{{c1::Euler's}} Theorem is:<br><br>{{c2::\\(z^{\\phi N} \\equiv 1 \\ mod\\&nbsp; N\\)}}<br>",
                        "where \\(N\\) is <i style=\"\">any</i> number (prime or not prime) and \\(z\\) is any number such that \\(gcd(z,N)=1\\)"
                    ],
                    "guid": "OeU=y4B3-P",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>{{c1::Fermat's Little}} Theorem is:<br><br>{{c2:: \\(z^{p-1} \\equiv 1 \\mod p\\)}}<br>",
                        "where \\(p\\) is a <i>prime number</i> and \\(z\\) is every number&nbsp;\\(1 \\le z \\le p-1\\)&nbsp;"
                    ],
                    "guid": "NF{{GI,^z/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>\\(\\phi 8 = {{c1::4}}\\)<br>",
                        "\\(\\phi N =\\) the # of integers between \\(1\\) and \\(N\\) that are relatively prime to \\(N\\)<br><br><u><b>step by step<br></b></u><br>\\(\\phi 8 = ?\\)<br><br>\\(\\overbrace{{1, 2, 3, 4, 5, 6, 7, 8}}^{\\text{ integers between 1 and N=8}}\\)<br><br>\\[\\begin{array}{rcl}gcd(1,8) &amp; = &amp; \\color{Green}1 \\\\gcd(2,8) &amp; = &amp; 2 \\neq 1 \\\\gcd(3,8) &amp; = &amp; \\color{Green}1\\\\gcd(4,8) &amp; = &amp; 4 \\neq 1\\\\gcd(5,8) &amp; = &amp; \\color{Green}1 \\\\gcd(6,8) &amp; = &amp; 2 \\neq 1\\\\gcd(7,8) &amp; = &amp; \\color{Green}1 \\\\gcd(8,8) &amp; = &amp; 8 \\neq 1&lt;br&gt;\\end{array}\\]<br>\\(\\overbrace{{1,3,5,7}}^{\\text{ integers between 1 and N=8 that gcd(z,8) = 1}}\\)<br><br>\\(\\left| {1,3,5,7} \\right| = \\textbf{4}\\)<br><br>\\(\\phi 8 = 4\\)<br><br>"
                    ],
                    "guid": "rSB!<Wz+/k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>where \\(p\\) is a {{c2::prime}} number:<br><br>\\(\\phi p = {{c1::(p-1)}}\\)<br><br>",
                        ""
                    ],
                    "guid": "JgsU~bvSR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><br>where \\(p\\) and \\(q\\) are {{c1::prime}} numbers and \\((N=pq)\\),&nbsp;<br><br>\\(Z^{\\phi N} \\equiv 1 \\text{ mod } N\\)<br><br>\\[\\begin{array}{lcl}\n\\phi N &amp; = &amp; \\phi (p \\cdot q)\\\\\n\\phi (p \\cdot q) &amp; = &amp; {{c2::\\phi p \\cdot \\phi q}}\\\\\n\\phi (p \\cdot q) &amp; = &amp; {{c3::(p-1)(q-1)}}\\end{array}\\]<br>",
                        "\\[\\begin{array}{lcl}\n\\phi p = (p-1)\\\\\n\\phi q = (q-1)\n\\end{array}\\]<br>"
                    ],
                    "guid": "Uloy@W:KZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Non-trivial Fermat Witnesses</h2><p>\n  {{c1::Carmichael numbers}} are {{c2::composite numbers with no non-trivial Fermat witnesses}}.</p>",
                        "Also known as pseudoprimes."
                    ],
                    "guid": "PEWJ$[b+#1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA</h1><h2>Simple Primality Test</h2><p>\n  For n-bit \\(r\\):</p><ol><li>{{c1::Choose \\(z\\) randomly from \\(\\{1, 2, \\ldots, r-1\\}\\)}}</li><li>{{c2::Compute \\(z^{r-1} \\stackrel{?}{\\equiv} 1 \\pmod r\\)}}</li><li>{{c3::If true, output \\(r\\) is prime. Else, output \\(r\\) is composite.}}</li></ol>",
                        "For a prime \\(r\\), the test is always correct. For a composite \\(r\\) (not Carmichael), there is a 0.5 probability of finding a non-witness \\(z\\) and reporting \\(r\\) as prime since half of all \\(z\\) will be a witness.<br>For an improved test, repeat k times. The probability of falsely reporting a composite \\(r\\) as prime reduces to \\(\\left(\\frac{1}{2}\\right)^k\\)."
                    ],
                    "guid": "C{g7q$[$-n",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "randomized_algorithms",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA Algorithm</h1><p>RSA is implemented for data security where \\(p = 5, q = 11\\). <br>What is the value of the decryption key if the value of the encryption key <i>e</i> is 27?<br></p>",
                        "\\[\\begin{array}{rcl}<br>d &amp;=&amp; e^{-1} \\pmod {(p-1)(q-1)}\\\\<br>gcd, a, b &amp;=&amp; \\text{extended-euclid}(40, 27)\\\\<br>b \\pmod {40} &amp;=&amp; 3<br>\\end{array}\\]"
                    ],
                    "guid": "b;i?ekO+Pq",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA Algorithm</h1><p>Using the RSA public key cryptosystem, if \\(p = 13, q = 31\\), and \\(d = 7\\), then the value of ‘e’ is:<br></p>",
                        "\\[\\begin{array}{rcl}<br>e &amp;=&amp; d^{-1} \\pmod {(p-1)(q-1)}\\\\<br>e &amp;=&amp; 7^{-1} \\pmod {(13-1)(31-1)}\\\\<br>gcd, a, b &amp;=&amp; \\text{extended-euclid}(360, 7)\\\\<br>b \\pmod {360} &amp;=&amp; 103<br>\\end{array}\\]"
                    ],
                    "guid": "dGPKn]gURV",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "RSA"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>RSA Algorithm</h1><p>Assume that the alphabet A-Z are represented by the numbers A=1 to Z=26. <br>Using \\(p = 3, q = 13, d = 7\\) and \\(e = 3\\) in the RSA algorithm, what is the value of ciphertext for the plain text 5?<br></p>",
                        "\\[m^e \\pmod {p \\times q} = 5^3 \\pmod {3 \\times 13} = 125 \\pmod {39} = 8\\]"
                    ],
                    "guid": "N{+T->m4g*",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "exam2",
                        "exercise",
                        "RSA"
                    ]
                }
            ]
        }
    ],
    "crowdanki_uuid": "b9a1b182-888b-11ec-a349-144f8ad73af7",
    "deck_config_uuid": "0e0a939a-a05c-11ed-8334-83f82e164357",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "0e0a939a-a05c-11ed-8334-83f82e164357",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0,
                    1440.0,
                    4320.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 3,
                "mult": 0.75
            },
            "maxTaken": 60,
            "name": "Trickle 2",
            "new": {
                "bury": true,
                "delays": [
                    2.0,
                    10.0,
                    1440.0,
                    4320.0
                ],
                "initialFactor": 2500,
                "ints": [
                    4,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 2,
                "separate": true
            },
            "newGatherPriority": 1,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 500
            },
            "reviewOrder": 0,
            "timer": 0
        },
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0,
                    1440.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.75
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": true,
                "delays": [
                    2.0,
                    10.0,
                    1440.0,
                    4320.0
                ],
                "initialFactor": 2500,
                "ints": [
                    4,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 50,
                "separate": true
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 500
            },
            "reviewOrder": 0,
            "timer": 0
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 0,
    "extendRev": 0,
    "media_files": [],
    "name": "GA Tech OMSCS::Graduate Algorithms",
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.cloze-inactive {\n  color: darkslateblue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: block;\n  text-align: left;\n  list-style: inside;\n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "description": "",
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Text",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "description": "",
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Extra",
                    "ord": 1,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Cloze",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}<br><br>\n{{Extra}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Cloze",
                    "ord": 0,
                    "qfmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}"
                }
            ],
            "type": 1,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: inline-block;\n  text-align: left; \n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Front",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Back",
                    "ord": 1,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Basic",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [
                "practice_exam"
            ],
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Deck}}<br>\n{{Front}}"
                }
            ],
            "type": 0,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
            "css": "/* GENERAL CARD STYLE */\n.card {\n  font-family: \"Helvetica LT Std\", Helvetica, Arial, Sans;\n  font-size: 150%;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n/* OCCLUSION CSS START - don't edit this */\n#io-overlay {\n  position:absolute;\n  top:0;\n  width:100%;\n  z-index:3\n}\n\n#io-original {\n  position:relative;\n  top:0;\n  width:100%;\n  z-index:2;\n  visibility: hidden;\n}\n\n#io-wrapper {\n  position:relative;\n  width: 100%;\n}\n/* OCCLUSION CSS END */\n\n/* OTHER STYLES */\n#io-header{\n  font-size: 1.1em;\n  margin-bottom: 0.2em;\n}\n\n#io-footer{\n  max-width: 80%;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 0.8em;\n  font-style: italic;\n}\n\n#io-extra-wrapper{\n  /* the wrapper is needed to center the\n  left-aligned blocks below it */\n  width: 80%;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 0.5em;\n}\n\n#io-extra{\n  text-align:center;\n  display: inline-block;\n}\n\n.io-extra-entry{\n  margin-top: 0.8em;\n  font-size: 0.9em;\n  text-align:left;\n}\n\n.io-field-descr{\n  margin-bottom: 0.2em;\n  font-weight: bold;\n  font-size: 1em;\n}\n\n#io-revl-btn {\n  font-size: 0.5em;\n}\n\n/* ADJUSTMENTS FOR MOBILE DEVICES */\n\n.mobile .card, .mobile #content {\n  font-size: 120%;\n  margin: 0;\n}\n\n.mobile #io-extra-wrapper {\n  width: 95%;\n}\n\n.mobile #io-revl-btn {\n  font-size: 0.8em;\n}\n",
            "flds": [
                {
                    "description": "",
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "ID (hidden)",
                    "ord": 0,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Header",
                    "ord": 1,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Image",
                    "ord": 2,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Question Mask",
                    "ord": 3,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Footer",
                    "ord": 4,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Remarks",
                    "ord": 5,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Sources",
                    "ord": 6,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Extra 1",
                    "ord": 7,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Extra 2",
                    "ord": 8,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Answer Mask",
                    "ord": 9,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "description": "",
                    "font": "Arial",
                    "media": [],
                    "name": "Original Mask",
                    "ord": 10,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Image Occlusion Enhanced",
            "req": [
                [
                    0,
                    "any",
                    [
                        2
                    ]
                ]
            ],
            "sortf": 1,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "{{#Image}}\n<div id=\"io-header\">{{Header}}</div>\n<div id=\"io-wrapper\">\n  <div id=\"io-overlay\">{{Answer Mask}}</div>\n  <div id=\"io-original\">{{Image}}</div>\n</div>\n{{#Footer}}<div id=\"io-footer\">{{Footer}}</div>{{/Footer}}\n<button id=\"io-revl-btn\" onclick=\"toggle();\">Toggle Masks</button>\n<div id=\"io-extra-wrapper\">\n  <div id=\"io-extra\">\n    {{#Remarks}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Remarks</div>{{Remarks}}\n      </div>\n    {{/Remarks}}\n    {{#Sources}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Sources</div>{{Sources}}\n      </div>\n    {{/Sources}}\n    {{#Extra 1}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Extra 1</div>{{Extra 1}}\n      </div>\n    {{/Extra 1}}\n    {{#Extra 2}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Extra 2</div>{{Extra 2}}\n      </div>\n    {{/Extra 2}}\n  </div>\n</div>\n\n<script>\n// Toggle answer mask on clicking the image\nvar toggle = function() {\n  var amask = document.getElementById('io-overlay');\n  if (amask.style.display === 'block' || amask.style.display === '')\n    amask.style.display = 'none';\n  else\n    amask.style.display = 'block'\n}\n\n// Prevent original image from loading before mask\naFade = 50, qFade = 0;\nvar mask = document.querySelector('#io-overlay>img');\nfunction loaded() {\n    var original = document.querySelector('#io-original');\n    original.style.visibility = \"visible\";\n}\nif (mask === null || mask.complete) {\n    loaded();\n} else {\n    mask.addEventListener('load', loaded);\n}\n</script>\n{{/Image}}\n",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "IO Card",
                    "ord": 0,
                    "qfmt": "{{#Image}}\n<div id=\"io-header\">{{Header}}</div>\n<div id=\"io-wrapper\">\n  <div id=\"io-overlay\">{{Question Mask}}</div>\n  <div id=\"io-original\">{{Image}}</div>\n</div>\n<div id=\"io-footer\">{{Footer}}</div>\n\n<script>\n// Prevent original image from loading before mask\naFade = 50, qFade = 0;\nvar mask = document.querySelector('#io-overlay>img');\nfunction loaded() {\n    var original = document.querySelector('#io-original');\n    original.style.visibility = \"visible\";\n}\nif (mask === null || mask.complete) {\n    loaded();\n} else {\n    mask.addEventListener('load', loaded);\n}\n</script>\n{{/Image}}\n"
                }
            ],
            "type": 0,
            "vers": []
        }
    ],
    "notes": []
}